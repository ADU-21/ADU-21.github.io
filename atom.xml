<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杜屹东的博客</title>
  
  <subtitle>学无止境</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.duyidong.com/"/>
  <updated>2018-03-29T13:10:19.000Z</updated>
  <id>https://www.duyidong.com/</id>
  
  <author>
    <name>杜屹东</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>英文时态详解</title>
    <link href="https://www.duyidong.com/2018/03/28/English-16-tense/"/>
    <id>https://www.duyidong.com/2018/03/28/English-16-tense/</id>
    <published>2018-03-28T15:16:37.000Z</published>
    <updated>2018-03-29T13:10:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>来 ThoughtWorks 两年了，英文使用也两年了，日常和工作中的交流几乎是没有问题，但是在说和写的时候总还觉得不地道，要么太啰嗦，要么说着说着逻辑就乱了，有时甚至感觉说英文像是在堆砌单词。最近补了一下英文语法，发现用错时态是我日常交流中最容易犯的错误，特此组织成文，方便日后查阅。</p><h1 id="时态的定义"><a href="#时态的定义" class="headerlink" title="时态的定义"></a>时态的定义</h1><p>我们已经知道复杂句由简单句构成，简单句有<strong>主系表</strong>、<strong>主谓</strong>、<strong>主谓宾</strong>、<strong>主谓宾宾补</strong>、<strong>主谓宾宾</strong>（授予）五大基本句型。大部分情况下，名词（主语、宾语）由<strong>定语</strong>修饰限定，动词（谓语）由<strong>状语</strong>修饰补充，就构成了日常使用的大部分简单的句子。在简单句的构成上英文和中文并没有太大差别，只是英文句式结构更严谨，表达的内容也不会有太大差异。而之所以英文和中文的学习有很大的差别，时态是一个重要的原因。</p><blockquote><p> 时态就是表示一个动作发生的<strong>时间</strong>和所处的<strong>状态</strong>。</p></blockquote><p>中文的动词侧重表意，也就是描绘动作本身，因此一个动词不管在何种语境下都是同样的说法同样的写法，因为他的含义是一样的；而英文中加入了时态的概念，在动词出现的时候就包含了关于这个动作“时间”和“状态”的信息，这也是为什么说英文描述比中文准确的原因，也是我们培养英语语感必须要迈过的一步。</p><ul><li><p>“时”就是这个动作发生的“时间”。英语中把时间分为三类：<code>过去</code>、<code>现在</code>和<code>将来</code>。</p></li><li><p>“态”就是这个动作在某个时刻的“状态”。动词共有四类状态，分别为：<code>一般式</code>、<code>进行式</code>、<code>完成式</code>和<code>进行完成式</code>。</p></li></ul><p>把这三个时间四种状态分别作为横轴和纵轴就形成了十二类时态的表格：（<strong>过去将来</strong>这个时间比较抽象，放到最后单独讲）</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">过去</th><th style="text-align:center">现在</th><th style="text-align:center">将来</th></tr></thead><tbody><tr><td style="text-align:center">一般式</td><td style="text-align:center">一般过去式<br> did</td><td style="text-align:center">一般现在式<br>do</td><td style="text-align:center">一般过去式<br>will do</td></tr><tr><td style="text-align:center">进行式</td><td style="text-align:center">过去进行式<br>was/were doing</td><td style="text-align:center">现在进行式<br>am/is/are doing</td><td style="text-align:center">将来进行式<br>will be doing</td></tr><tr><td style="text-align:center">完成式</td><td style="text-align:center">过去完成式<br>had done</td><td style="text-align:center">现在完成式<br>have/has done</td><td style="text-align:center">将来完成式<br>will have done</td></tr><tr><td style="text-align:center">完成进行式</td><td style="text-align:center">过去完成进行式<br>had been done</td><td style="text-align:center">现在完成进行式<br>have/has been done</td><td style="text-align:center">将来完成进行式<br>will have been done</td></tr></tbody></table><p>只看表格里的中文名词可能比较难以理解，下面我们把每个时态带入具体场景进行理解：</p><h2 id="一般式"><a href="#一般式" class="headerlink" title="一般式"></a>一般式</h2><p>强调动作本身，即<strong>只强调动作发生的时间，不强调动作的状态</strong>；也就是说说这句话的人只关心这件事发生在过去现在还是将来，而不关心这件事有没有完成。</p><ul><li><p>一般过去式： <code>sb. did sth.</code></p><ul><li><p>表示过去的动作：I <u>got up</u> late this morning.</p></li><li><p>表示过去的事实：Colubus <u>discovered</u> America in 1742.</p></li></ul></li><li><p>一般现在式：<code>sb. do sth.</code></p><ul><li><p>表示事物现在的情况或状态，最典型的就是主系表结构，例如：I <u>am</u> a developer.</p></li><li><p>表示经常性、习惯性动作，常伴随时间副词修饰：I never/often/always <u>do</u> sth.</p></li><li><p>表示客观真理、格言，如： Time <u>filies</u>.</p></li></ul></li><li><p>一般将来式：<code>sb. will do sth.</code> 表示将来的动作、状态或是倾向。</p><ul><li><p>Will 表示意愿时，主语是人；表预测时，主语是物：I <u>will do</u> this card tomorrow. This part of the code <u>will become</u> difficult to maintain.</p></li><li><p>Be going to + 动词原形，多表计划，主语多为人：I<u>‘m going to</u> have lunch.</p></li><li><p>Be about to + 动词原形，表示即将： He <u>is about to</u> leave for a meeting.</p></li></ul></li></ul><p>对于一般现在式和一般将来式一般不容易犯错误，而容忽略的往往是一般过去式，因为汉语中习惯在动词末加“了”字补充说明这个动作已经发生，而英文则是要在这个动词出现的同时就带出“已经发生”的信息，因此容易被忽略。像说“I breake the pipeline.” ，break 是一个瞬间动词，因此说这句话的时候必然流水线已经红了，就应该用过去式“I <u>broke</u> the pipeline”。</p><h2 id="进行式"><a href="#进行式" class="headerlink" title="进行式"></a>进行式</h2><p>强调动作过程，表示正在做某事。</p><ul><li><p>过去进行式：<code>sb. was doing sth.</code></p><ul><li>表示过去正在做某事：I <u>was pairing</u> with Eli when Luke call me.</li></ul></li><li><p>现在进行式：<code>sb. be doing sth.</code></p><ul><li><p>表示现在正在发生的动作：It<u>’s raining</u> heavily now.</p></li><li><p>表示即将发生的动作，通常表示“位移”短暂动词 come, go, arrive, leave, start, begin, return, die, take，此时 be 动词译为“即将”：We <u>are going to</u> lunch soon.</p></li><li><p>主系表的一般态和进行态区别：主系表句型在口语中常表一般现在时，但如果强调此时的状态，可以用现在进行时。you are very rude! -&gt; you <u>are being</u> very rude! 你现在的行为粗鲁，而不是你这个人。</p></li></ul></li><li><p>将来进行式：<code>sb. will be doing sth.</code></p><ul><li>表示将来某时正在做的事情，强调对动作本身的描写，也是一般态的生动模式。例如：They <u>will be arriving</u> here tomorrow. 如果使用 arrive here 也可以，只是没有那么生动。</li></ul></li></ul><p>进行式容易忽略的一点是<strong>进行式只针对延续性动词</strong>，任何一个进行态的句子都可以改成一般态，但是一般态却必须是延续动词才能改成进行态。比如“结婚”和“开始”就是瞬间动词，中文中常有“他们正在结婚”，“比赛正在开始”的说法，而英文却不能用“They were marrying last week.” 只能说“They <u>married</u> last week.”，或者把“结婚”换成“结婚仪式”，成为延续性动词，用“They <u>are having</u> a wedding ceremony” 来表达正在进行婚礼。</p><h2 id="完成式"><a href="#完成式" class="headerlink" title="完成式"></a>完成式</h2><p>强调动作结果，在表意中时间被弱化，因此很容易忽略时态中的“时”。</p><ul><li><p>过去完成式：<code>sb. had did sth.</code></p><ul><li>表示截止到过去某时位置所完成的动作或经验的总结。过去完成时不能单独存在，要与另一使用一般过去时的句子或者表示过去的副词短语连用。had 译为“已经”或”曾经“：I <u>had opened</u> this feature toggle before last release.</li></ul></li><li><p>现在完成式：<code>sb. have/has did sth.</code></p><ul><li><p>表示到现在为止已经完成的动作（发生时间不明确）：DICE Team <u>has completed</u> the AMI upgrade.</p></li><li><p>如果是延续性动词，表示持续到现在的动作或状态：（be 动词是可延续的）Cloud hosting team <u>has been doing</u> SSL upgrade for two weeks.</p></li><li><p>现在完成时常用时间副词：</p><pre><code>- 自从... since + 时间点- 有若干时间之久… for + 时间段- 到目前为止... so far/up to now- 最近... recently/lately- 一次/两次/几次/多次... once/twice/a few times/many times- 过去若干年/月/日以来... over/during/for + the last/past + 数字 + years/months/days</code></pre></li></ul></li><li><p>未来完成式：<code>sb. will have did sth.</code></p><ul><li>表示到将来某时为止所做完成或仍然继续的动作或经验等。常与介词 by 构成时间状语连用，表示“到…的时候”，表示对将来这个时间点之前的一个或一系列动作的总结：By the end of this iteration, we <u>will have finished</u> work on the new brand.</li></ul></li></ul><p>这是一个充满“have/has”的句式，写邮件的时候很容易忽略三单，例如 Kira <u>has done</u> it  before. 另外，就如开头说的，完成式强调的是结果的状态，因此时间会被弱化，因此要注意根据完成时间在现在时间的前后选择<code>had</code>、<code>have/has</code>、或是<code>will have</code>。</p><h2 id="完成进行式"><a href="#完成进行式" class="headerlink" title="完成进行式"></a>完成进行式</h2><p>同时强调动作的结果和过程，是完成式的延续态，也就是说同样只适用于延续动词，且让这个延续的动作显得更生动，例如：I have work for this account for two years -&gt; I have been working for this account for two years. 两句话意思完全相同，但是第二句更加形象生动。</p><ul><li><p>过去完成进行式：<code>sb. had been doing sth.</code></p><ul><li>表达一直继续到过去某时，而当时仍然在继续的动作。过去完成进行时的句中必须有表示过去的时间状语：We <u>had been tracing</u> that bug for 8 hours before another team solved it.</li></ul></li><li><p>现在完成进行式：<code>sb. have/has been doing sth.</code></p><ul><li>表示一直继续到现在，且可能继续下去的动作。通常和表示时间段的副词连用，如 for, since, all morning…   Kelly <u>has been working</u> on this card for 28 days.</li></ul></li><li><p>将来完成进行式：<code>sb. will have been doing sth.</code> 一直持续到将来某时，且可能继续下去的动作多用于叙述性故事中，或间接引语中：He told me that by the end of this year he <u>would have been working</u> at ThoughtWorks for 5 years.</p></li></ul><p>这个也算是很常用的时态，尤其是表示”这个东西我做了一段时间了，现在也仍在做的时候，要用现在完成进行式，同样注意第三人称单数。</p><hr><h2 id="过去将来时"><a href="#过去将来时" class="headerlink" title="过去将来时"></a>过去将来时</h2><p>除了以上提到的十二中时态，还有一个稍微特殊的时间叫做<strong>“过去将来”</strong>，指的是“站在过去看将来”，其用法与将来时只有一个差别，就是把“will”换成“would”：</p><ul><li><p>一般过去式：<code>sb. would do sth.</code></p><ul><li>站在某个过去的时间点看将会发生的动作：He told me he <u>would do</u> it as quick as possible.</li></ul></li><li><p>过去将来进行式：<code>sb. would be doing sth.</code></p><ul><li>站在某个过去的时间点，从这个时间点看一个之后的时间点（或时间段）正在发生的动作：He knew that I <u>would be living</u> in Melburne next month.</li></ul></li><li><p>过去将来完成式：<code>sb. would have done sth.</code></p><ul><li>站在某个过去的时间点，对一个之后的时间点已经发生了的动作做总结：WaterStrong said he <u>would have left</u> for Sydney by the end of next month.</li></ul></li><li><p>过去将来完成进行式：<code>sb. would have been doing sth.</code></p><ul><li>站在过去的某个时间点，对一个之后的时间点正在发生的动作做总结：I knew by July Jimmy <u>would have been working</u> there for 3 years.</li></ul></li></ul><p>在读书的时候会比较多出现这个时态，类比将来式的使用即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来 ThoughtWorks 两年了，英文使用也两年了，日常和工作中的交流几乎是没有问题，但是在说和写的时候总还觉得不地道，要么太啰嗦，要么说着说着逻辑就乱了，有时甚至感觉说英文像是在堆砌单词。最近补了一下英文语法，发现用错时态是我日常交流中最容易犯的错误，特此组织成文，方
      
    
    </summary>
    
      <category term="English" scheme="https://www.duyidong.com/categories/English/"/>
    
    
      <category term="学习" scheme="https://www.duyidong.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="英文" scheme="https://www.duyidong.com/tags/%E8%8B%B1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>在 AWS 流水线中使用 CodeDeploy</title>
    <link href="https://www.duyidong.com/2018/02/26/aws-codedeploy/"/>
    <id>https://www.duyidong.com/2018/02/26/aws-codedeploy/</id>
    <published>2018-02-26T14:24:39.000Z</published>
    <updated>2018-02-27T01:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>AWS 为开发者提供了 CodeCommit -&gt; CodeBuild -&gt; CodeDeploy 三个服务分别用于管理应用的代码库、构建、部署三个环节，并使用 CodePipline 编排流水线，以及使用 CodeStar 以快速构建模板项目。</p><p><img src="/images/aws-pipeline.png" alt=""></p><h1 id="AWS-上的流水线"><a href="#AWS-上的流水线" class="headerlink" title="AWS 上的流水线"></a>AWS 上的流水线</h1><p>CodeCommit 是一个私有的 git 代码版本管理库，CodeBuild 是一个基于 Docker 的构建环境，可以用一个叫<code>buildspec.yml</code>的 Yaml 配置文件定义构建规则（其实跟 Bash 脚本没啥区别），CodePipeline 是用于串联各个 Stage，这些都没啥新鲜的，对 AWS 而言，值得一书的恐怕还属 CodeDeploy。</p><h1 id="CodeDeploy-介绍"><a href="#CodeDeploy-介绍" class="headerlink" title="CodeDeploy 介绍"></a>CodeDeploy 介绍</h1><p>CodeDeploy 在产品生命周期中掌管部署环节，支持 EC2 和 Lambda，亮点是和 AWS 其他服务高度集成，提供零宕机部署（包括蓝绿部署）。CodeDeploy 的规则定义起来比较简单，还可以和 Puppet/Chef 集成，但是需要对 AWS 的基础服务比如 EC2、ASG、ELB、S3 比较了解，上手难度并不大。本文主要解释基于 EC2 的 CodeDeploy 使用。</p><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p>AWS  CodeDedeploy 定义了一些资源名称：</p><ul><li><strong>Application:</strong> 一个应用，也对应项目里一个 Project，一般对应一个代码仓库，包含多个环境。可以定义多个<strong>Deployment Groups</strong>。</li><li><strong>Deployment Groups:</strong> 对应应用的一个环境，包含了 instance 选区规则（Tag/ASG）、ELB、触发规则、Rollback 策略、权限（Role）以及 <strong>Deployment Configuration</strong>。</li><li><strong>Deployment Configuration:</strong> 部署策略，有 AllAtOnce、HalfAtATime、OneAtATime 三种默认策略，也支持自己定制，即指定在部署过程中一个 Deployment Groups 至少有多少个（百分比）的 instance 要在服务中。</li><li><strong>Revision:</strong>一个新版本及为一个 Revision，需要提供 Repo（S3/Github）、Deployment Configuration、Rollback 策略等信息。</li></ul><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><p>CodeDeploy 的对象可以来自 S3 或者 Github，和所有的 AWS 资源对象操作一样，Trigger 方式可以选择 Console、cli、或是 sdk。 </p><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>触发相关的设置在 <strong>Deployment Groups</strong> 中，选择<strong>Deploy new revision</strong>，这里有两个可选方式：</p><ul><li>S3 object + ETag: 被部署的文件必须被打包为一个文件（<code>.zip</code>或是 <code>.tar</code>）并上传到 S3 上，ETag 是该文件的一个哈希，会随文件变更改变，因此 Revision 里面实际上带了文件位置和版本号两个信息。</li><li>Github repository + commit ID: 与 S3 一样，信息需要定位到 Repo + 版本号，不同的是 Github 不需要把部署文件和部署脚本一起打包，另外第一次使用这个功能需要 Github 授权给 AWS CodeDeploy。</li></ul><h3 id="命令行-Deploy-to-S3-触发"><a href="#命令行-Deploy-to-S3-触发" class="headerlink" title="命令行 Deploy to S3 触发"></a>命令行 Deploy to S3 触发</h3><p>AWS CLI 有一个 Deploy 的 namespace 可以用来触发 Application Deploy，对于 S3 参数如下：</p><pre><code>aws deploy register-application-revision --application-name DemoApp --s3-location bundleType=tar,eTag=0d088076b9baa9bd71369367119e6b33,bucket=yidong-codedeploy,key=demoRevision.tar</code></pre><p>Github 如下：</p><pre><code>aws deploy register-application-revision —application-name DemoApp —github-location commitID=&lt;value&gt;,repository=adu-21/aws-codedeploy</code></pre><p>如果被部署文件在本地而还没有提交到 S3 可以使用 <code>aws deploy publish</code>一键打包、上传、发布：</p><pre><code>aws deploy push --application-name DemoApp --ignore-hidden-files --s3-location s3://yidong-codedeploy/newDemoRevision.zip --source .</code></pre><h3 id="Github-提交自动触发"><a href="#Github-提交自动触发" class="headerlink" title="Github 提交自动触发"></a>Github 提交自动触发</h3><p>Github 的集成可以做到部署文件提交到 Github 上就有一个 Webhook 到 CodeDeploy，并 Pull 最新版代码到 instance 上，需要给 CodeDeploy 配置 Github 账户 <code>repo_deployment</code>权限的 <strong>access token</strong>，并在 Repo 的 <strong>Services</strong> 中加入 AWS CodeDeploy 和 Github Auto-deployment 两个服务，具体可见：<a href="https://github.com/ADU-21/aws-codedeploy/settings/installations" target="_blank" rel="noopener">https://github.com/ADU-21/aws-codedeploy/settings/installations</a>：</p><p><img src="/images/aws-codedeploy-setting.png" alt=""></p><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>Deploy 执行的逻辑写在被部署文件根目录的一个 <code>appspec.yml</code>文件中，参见：<a href="https://github.com/ADU-21/aws-codedeploy/blob/master/appspec.yml" target="_blank" rel="noopener">https://github.com/ADU-21/aws-codedeploy/blob/master/appspec.yml</a>:</p><pre><code>version: 0.0                              # 版本号os: linux                                 # 操作系统，只有 linux 和 windows 两个可选项files:                                    # 定义某个本地文件拷贝到目标服务器的某个地址  - source: files/index.html    destination: /var/www/htmlpermissions:                              # 目标服务器上文件权限  - object: /var/www/html    pattern: index.html    owner: apache    group: apache    mode: 644    type:      - filehooks:                                     # 定义部署前后的一系列流程，通常调用本地完成  BeforeInstall:    - location: scripts/webserver-stop.sh    - location: scripts/delete-old-index.sh  AfterInstall:    - location: scripts/sleep.sh    - location: scripts/webserver-start.sh</code></pre><p>对于 Hook 模块，有 ELB 的和没有 ELB 的有以下可选子模块：</p><p><img src="https://docs.aws.amazon.com/codedeploy/latest/userguide/images/lifecycle-event-order-in-place.png" alt=""></p><center><strong>图片来自：<a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html" target="_blank" rel="noopener">官方文档</a></strong></center><h2 id="蓝绿部署"><a href="#蓝绿部署" class="headerlink" title="蓝绿部署"></a>蓝绿部署</h2><p>AWS CodeDeploy 提供配置简单的 Blue/Green Deploy 服务，只需要配置 ELB 和 ASG 就可以完成自动创建新环境、Switch ELB、Terminate 旧环境几个步骤（如下图），完整步骤详见<a href="https://aws.amazon.com/blogs/devops/performing-bluegreen-deployments-with-aws-codedeploy-and-auto-scaling-groups/" target="_blank" rel="noopener">官方博客</a>。</p><p><img src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2017/04/19/codedeployresults.png" alt=""></p><center>图片来自：<a href="https://aws.amazon.com/blogs/devops/performing-bluegreen-deployments-with-aws-codedeploy-and-auto-scaling-groups/" target="_blank" rel="noopener">Performing Blue/Green Deployments with AWS CodeDeploy and Auto Scaling Groups</a></center><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>今年 AWS 发布财报营收已经被微软超越。亚马逊的产品不得不说性能稳定性强大，但是易用性和商业模式上仍不及国内阿里、腾讯的产品，甚至不如 Rancher、Hashicorp 这样一些小公司的产品简洁、易上手。过去的一年在各种 PaaS 的竞争中 AWS 逐渐面临被 IaaS 化的命运，投资数年的 Serverless 因为它的不稳定、不成熟和平台绑定，在过去的几年中鲜有公司真正涉足，大多在观望状态。就我个人的使用体验而言，Serverless 的架构在较复杂的业务场景下对架构会带来非常大的挑战，资费优势也被 AWS 抖机灵的收费方式蚕食殆尽，17 年 AWS 收购 Cloud9 及迅速提升 Developer Tools 板块服务的行为就是想要补足 PaaS 这块短板。</p><p>我一直觉得像 FLAG（Facebook，LinkedIn，Amazon，Google）这种大公司，在如此体量的前提下还面临大量的服务更新和创新需求，还要求内部协作和资源共享，在多年的摸索中已经有了一套很好用的内部工具链，做 PaaS 只取决于你要如何以及以何种方式把这些工具公开出来。互联网的普及越来越广，企业越来越需要平台来支撑可持续、快速的迭代能力，大企业基于开源项目自建平台，小公司就向大公司租用 PaaS 服务。对讲求效率的小公司而言，一切非业务核心的技术能买则买，能外包就外包，能花钱的解决的问题，决不要花时间。</p><p>PaaS 仍然是很有潜力的一片蓝海，今年可以看到以阿里云效为代表的 DevOps 平台已经在发力，未来必然可以看到更加成熟的产品。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AWS 为开发者提供了 CodeCommit -&amp;gt; CodeBuild -&amp;gt; CodeDeploy 三个服务分别用于管理应用的代码库、构建、部署三个环节，并使用 CodePipline 编排流水线，以及使用 CodeStar 以快速构建模板项目。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Amazon Web Services" scheme="https://www.duyidong.com/categories/Amazon-Web-Services/"/>
    
    
      <category term="小计" scheme="https://www.duyidong.com/tags/%E5%B0%8F%E8%AE%A1/"/>
    
      <category term="AWS" scheme="https://www.duyidong.com/tags/AWS/"/>
    
      <category term="工具" scheme="https://www.duyidong.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Cloud" scheme="https://www.duyidong.com/tags/Cloud/"/>
    
      <category term="Pipeline" scheme="https://www.duyidong.com/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>使用 Kcptun 加速 Shadowsocks</title>
    <link href="https://www.duyidong.com/2018/02/25/kcptun-shadowsocks/"/>
    <id>https://www.duyidong.com/2018/02/25/kcptun-shadowsocks/</id>
    <published>2018-02-25T13:40:32.000Z</published>
    <updated>2018-02-25T15:13:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2017/11/03/how-to-setup-ss-on-linode/">搭建完加强版 Shadowsocks</a>后如果希望进一步减少延迟，或者在网络比较差的地方也想流畅使用代理，这篇文章会对你有帮助。笔者亲测可观看 Youtube 2K 视频。</p><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>使用代理上网，我们发出的网络请求实际上经过了“本地-&gt;代理服务器-&gt;目标服务器”两段网络请求，后半段发生在外网的网络请求在<a href="/2017/11/03/how-to-setup-ss-on-linode/">上一篇文章</a>中已经介绍过可以通过开启增强版 BBR 增加代理稳定性，这篇文章里讲到的 Kcptun 用法目标则是为了以牺牲一定带宽的方式，降低本地到代理服务器这段网络请求的延迟，以提高上网速度。</p><h1 id="实现原理——Kcptun-介绍"><a href="#实现原理——Kcptun-介绍" class="headerlink" title="实现原理——Kcptun 介绍"></a>实现原理——Kcptun 介绍</h1><p><a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener">Kcptun</a> 是一个非常简单和快速的，基于 <a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">KCP 协议</a>的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。计算机网络课上我们学过，七层网络结构中运输层的 UDP 是一个无连接、尽最大努力的数据传输服务，优点是交付效率高、速度快；缺点是不提供可靠交付，而 KCP 是一个快速可靠协议，以选择性重复发包的方式，能以比 TCP 浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。</p><p><img src="https://blog.kuoruan.com/wp-content/uploads/2016/06/kcptun.png" alt=""></p><center>Kcptun 工作示意图 图片来自：<a href="https://blog.kuoruan.com/" target="_blank" rel="noopener"><strong>扩软博客</strong></a></center><h1 id="搭建-Kcptun"><a href="#搭建-Kcptun" class="headerlink" title="搭建 Kcptun"></a>搭建 Kcptun</h1><p>那么，这么好的工具，该怎么用呢？<br>Kcptun 的安装比较繁琐，万幸的是有人写成了自动安装脚本，包含了常用设置和开机自启的配置，我以<a href="/2017/11/03/how-to-setup-ss-on-linode/">上一篇文章</a>中搭建的 Shadowsocks 为基础，简要介绍一下搭建过程，完整版可见<a href="https://blog.kuoruan.com/110.html" target="_blank" rel="noopener">脚本作者博客</a>。<br>登录你的 Shadowsocks 服务器，运行：</p><pre><code>wget --no-check-certificate https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.sh # 下载脚本chmod +x ./kcptun.sh     # 添加执行权限./kcptun.sh              # 运行安装</code></pre><p>最后一个命令运行的是一个带交互功能的命令工具，除了“<u>需要加速的端口</u>”和“<u>Kcptun 密码</u>”需要自己定义，其他所有提示都可以直接回车使用默认值，脚本运行完后，把“<u>可使用的客户端配置文件</u>”复制下来，保存到本地，命名为 <code>config.json</code> 文件，并记录下服务器版本（如<code>20171201</code>），在启动客户端的时候会用到。<br>检查时候运行成功：</p><pre><code>service supervisord status    # 服务管理服务是否正常运行supervisorctl status kcptun   # kcptun 是否正常运行</code></pre><p>查看状态分别是 <code>Active</code>和 <code>running</code>则说明安装成功。</p><h1 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h1><p>以命令行的代理为例，加上 Tcptun 后，一次命令行请求的顺序就变成了：<strong>proxychains -&gt; ss-agent -&gt; kcptun-agent -&gt; kcptunu-server -&gt; ss-server</strong>，也就是说 GoAgent 配置的 ss-agent 不再转发到远程的 ss-server 服务器地址，而是指向本地的 kcptun 监听的地址（127.0.0.1:&lt;监听端口&gt;），而 kcptun-agent 服务则需要知道远程的kcptun-server 的地址和端口。kcptun-agent 的配置不需要亲自操心，已经在服务器 Setup 后记录的 <code>config.json</code> 文件中了，因此客户端的操作是：</p><h2 id="第一步：客户端-Kcptun-配置"><a href="#第一步：客户端-Kcptun-配置" class="headerlink" title="第一步：客户端 Kcptun 配置"></a>第一步：客户端 Kcptun 配置</h2><p>在 <a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="noopener">https://github.com/xtaci/kcptun/releases</a> 找到对应服务器版本（在安装完成后显示）的客户端版本（<code>darwin</code>是给 OSX 的），下载并解压，我们只需要<code>client_darwin_amd64.sh</code>这一个文件，在客户端执行：</p><pre><code>./client_darwin_amd64.sh -c config.json</code></pre><p>看到日志输出 <code>connection: ...</code>则说明连接成功，这个时候在服务器端运行之前用于安装 kcptun 的脚步也应该能看到客户端连上的信息：</p><pre><code>./kcptun.sh log</code></pre><h2 id="第二步：客户端-GoAgentX-配置"><a href="#第二步：客户端-GoAgentX-配置" class="headerlink" title="第二步：客户端 GoAgentX 配置"></a>第二步：客户端 GoAgentX 配置</h2><p>将 GoAgentX 中原有配置的 ServerAdress 改成 127.0.0.1，并把 ServerProt 设置为 <code>config.json</code>中<code>localaddr</code>所指的端口即可。<br>正如上文所说，现在 Shadowsocks 的服务器地址由  Kcptun 记录，ss-agent 只需要指向 Kcptun 的客户端进程即可；其他所有配置，包括 <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">proxychains</a> 和 <a href="chrome-extension://padekgcemlokbadohgkifijomclgjgif/options.html#!/about" target="_blank" rel="noopener">SwitchyOmega</a> 都不需要变更。这个时候再用代理上网的时候就可以看到 Kcptun 有数据流开闭的日志，说明 Kcptun 启用成功！</p><blockquote><ul><li>References:</li><li><a href="https://blog.kuoruan.com/102.html" target="_blank" rel="noopener">https://blog.kuoruan.com/102.html</a></li><li><a href="https://blog.kuoruan.com/110.html" target="_blank" rel="noopener">https://blog.kuoruan.com/110.html</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;/2017/11/03/how-to-setup-ss-on-linode/&quot;&gt;搭建完加强版 Shadowsocks&lt;/a&gt;后如果希望进一步减少延迟，或者在网络比较差的地方也想流畅使用代理，这篇文章会对你有帮助。笔者亲测可观看 Youtube 2K 视频
      
    
    </summary>
    
      <category term="工具" scheme="https://www.duyidong.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="代理" scheme="https://www.duyidong.com/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="Shadowsocks" scheme="https://www.duyidong.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Java系列（五）——UML类图和面向对象五大原则</title>
    <link href="https://www.duyidong.com/2018/02/15/UML-and-SOLID/"/>
    <id>https://www.duyidong.com/2018/02/15/UML-and-SOLID/</id>
    <published>2018-02-15T02:50:33.000Z</published>
    <updated>2018-02-14T08:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目上经历了一次比较大的重构，把之前不太清晰一些类关系梳理了一下，突然发现 UML 图是个很好用的东西，特此温习一下。顺便复习一下面向对象五大原则，对 clean code 可以说是有很大的帮助。</p><h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>UML 图中类和接口对象的表示如图所示：</p><p><img src="/images/Class_Interface_UML.png" alt=""></p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>在UML类图中，对象之间常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。</p><h3 id="泛化关系（Generalization）"><a href="#泛化关系（Generalization）" class="headerlink" title="泛化关系（Generalization）"></a>泛化关系（Generalization）</h3><p>对于面向对象语言，UML 中所说的泛化关系就是指类的<strong>继承</strong>关系，如图所示，Tiger 是 Animal 的子类：</p><p><img src="https://upload-images.jianshu.io/upload_images/1346433-af095465558161ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/202" alt=""></p><center><strong>泛化</strong> 图片来源于：<a href="https://www.jianshu.com/p/4cd95d4ddb59" target="_blank" rel="noopener">简书-详解UML图之类图</a></center><h3 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h3><p>一个类实现一个接口，如图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1346433-4cea5dc72a898986.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/204" alt=""></p><center><strong>实现</strong> 图片来源于：<a href="https://www.jianshu.com/p/4cd95d4ddb59" target="_blank" rel="noopener">简书-详解UML图之类图</a></center><h3 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a>组合(Composition)</h3><p>体现整体与部分间的关系，整体与部分是不可分的，部分不能离开整体而单独存在，整体的生命周期结束也就意味着部分的生命周期结束；比如公司和部门的关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/1346433-84881e93d5ef165a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/218" alt=""></p><center><strong>组合</strong> 图片来源于：<a href="https://www.jianshu.com/p/4cd95d4ddb59" target="_blank" rel="noopener">简书-详解UML图之类图</a></center><h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><p>和组合一样，也是整体与部分的关系，但是程度要稍弱一些，部分可以独立于整体单独存在，如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</p><p><img src="https://upload-images.jianshu.io/upload_images/1346433-3ee670e59b466df0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/389" alt=""></p><center><strong>聚合</strong> 图片来源于：<a href="https://www.jianshu.com/p/4cd95d4ddb59" target="_blank" rel="noopener">简书-详解UML图之类图</a></center><h3 id="关联（Association"><a href="#关联（Association" class="headerlink" title="关联（Association)"></a>关联（Association)</h3><p>上面提到的组合和聚合都可以说是关联关系的一种，如果 A 类中成员变量是用 B 类（接口）来声明的变量，那么 A 和 B 的关系是关联关系，称 A 关联于 B。关联关系可以是双向的。表示方式如图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1346433-f2e9554f7e2b3d20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/558" alt=""></p><center><strong>关联</strong> 图片来源于：<a href="https://www.jianshu.com/p/4cd95d4ddb59" target="_blank" rel="noopener">简书-详解UML图之类图</a></center><h3 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h3><p>如果 A 类中某个方法的参数是用 B 类（接口）来声明的变量或某个方法返回的数据类型是 B 类型，那么 A 和 B 是依赖关系。即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖。表示方式如图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1346433-1ab91901e0af0725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/196" alt=""></p><center><strong>依赖</strong> 图片来源于：<a href="https://www.jianshu.com/p/4cd95d4ddb59" target="_blank" rel="noopener">简书-详解UML图之类图</a></center><p>各种关系的强弱顺序：<br><strong>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong><br>下面这张UML图，比较形象地展示了各种类图关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/1346433-9ec0a861d9b58072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><center>图片来源于：<a href="https://www.jianshu.com/p/4cd95d4ddb59" target="_blank" rel="noopener">简书-详解UML图之类图</a></center><p>这里还有一篇用 UML 图来表示经典设计模式的文章：<a href="http://design-patterns.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">图说设计模式</a>，非常不错，值得一读。</p><h1 id="面向对象五大原则（S-O-L-I-D）"><a href="#面向对象五大原则（S-O-L-I-D）" class="headerlink" title="面向对象五大原则（S.O.L.I.D）"></a>面向对象五大原则（S.O.L.I.D）</h1><p>面向对象有三大特征：封装(Encapsulation)、继承(Inheritance)、多态(Polymorphism)，还有五大原则：<strong>SOLID</strong>（<strong>单一功能、开闭原则、里氏替换、接口隔离</strong>以及<strong>依赖反转</strong>），当这些原则被一起应用时，它们使得一个程序员开发一个容易进行软件维护和扩展的系统变得更加可能。SOLID被典型的应用在测试驱动开发上，并且是敏捷开发以及自适应软件开发的基本原则的重要组成部分。</p><h2 id="单一职责原则（Single-Resposibility-Principle）"><a href="#单一职责原则（Single-Resposibility-Principle）" class="headerlink" title="单一职责原则（Single-Resposibility Principle）"></a>单一职责原则（Single-Resposibility Principle）</h2><blockquote><p>对象应该仅具有一种单一功能（职责），只有一个引起它变化的原因。    </p></blockquote><p>职员类例子： 比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要ifelse判断是哪种情况，从类结构上来说将会十分臃肿，并且上述三种的职员类型，不论哪一种发生需求变化，都会改变职员类，这就增加了代码的维护成本。</p><h2 id="开放封闭原则（Open-Closed-principle）"><a href="#开放封闭原则（Open-Closed-principle）" class="headerlink" title="开放封闭原则（Open-Closed principle）"></a>开放封闭原则（Open-Closed principle）</h2><blockquote><p>“软件体应该是<strong>对于扩展开放</strong>的，但是<strong>对于修改封闭</strong>的。“</p></blockquote><p>如果要在一个软件中增加新的模块的时候不需要修改现有核心模块，那这个设计就是满足开放封闭原则的。这就要求在给出一个设计时，首先考虑到用户需求的变化，将应对用户变化的部分设计为对扩展开放，而设计核心部分应该抽象出不改动或者很少改动的接口或抽象类。这个过程会在设计开始时和重构同不断发生。如下图所示， DataBaseInterface 就是系统中修改关闭的部分，而接口的实现 SqliteDatabase 和 CustomDatabase 就是对扩展开放的部分。</p><p><img src="https://upload-images.jianshu.io/upload_images/458529-45767c7119b61c69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/358" alt=""></p><center><strong>开闭原则</strong> 图片来自：<a href="https://www.jianshu.com/p/e378025920f8" target="_blank" rel="noopener">谈谈面向对象设计(OOD)原则</a></center><h2 id="里氏替换原则（Liskov-Substituion-Principle）"><a href="#里氏替换原则（Liskov-Substituion-Principle）" class="headerlink" title="里氏替换原则（Liskov-Substituion Principle）"></a>里氏替换原则（Liskov-Substituion Principle）</h2><blockquote><p>“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”</p></blockquote><p><strong>派生类（子类）对象能够替换其基类（超类）对象被使用。</strong>也就是任何基类可以出现的地方，其子类一定可以出现。里氏替换原则是继承和复用的基石，只有当衍生类可以替换掉基类，而软件单位的功能不受到影响时，基类才能真正的被复用，而衍生类也能够在基类的基础上增加新的行为。</p><h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><blockquote><p>“多个特定客户端接口要好于一个宽泛用途的接口”</p></blockquote><p><strong>客户端不应该被迫依赖于它所不使用的接口（方法）。</strong>简单来说就是客户端需要什么接口，就提供给它什么样的接口，其它多余的接口就不要提供，不要让接口变得臃肿，否则当对象一个没有使用的方法被改变了，这个对象也将会受到影响。接口的设计应该遵循最小接口原则，其实这也是高内聚的一种表现，使得系统更容易重构，更改和重新部署。</p><p>举个例子（这个例子来源于<a href="https://www.jianshu.com/p/e378025920f8" target="_blank" rel="noopener">简书</a>）：比如我们有个自行车接口，这个接口包含了很多方法，包括GPS定位，以及换挡的方法</p><p><img src="https://upload-images.jianshu.io/upload_images/458529-6413661553a89ece.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/249" alt=""></p><center><strong>不满足ISP原则</strong></center><p>然后我们发现即便普通的自行车也需要实现GPS定位以及换挡的功能，显然这违背了接口隔离的原则。遵循接口最小化的原则，我们重新设计：</p><p><img src="https://upload-images.jianshu.io/upload_images/458529-0ae1f5ed465562dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/478" alt=""></p><center><strong>满足ISP原则</strong></center><p>这样一来每个接口的功能相对单一，CommonBike 类不需要实现它不使用的接口，这也就满足了ISP原则。</p><h2 id="依赖反转原则（Dependecy-Inversion-Principle）"><a href="#依赖反转原则（Dependecy-Inversion-Principle）" class="headerlink" title="依赖反转原则（Dependecy-Inversion Principle）"></a>依赖反转原则（Dependecy-Inversion Principle）</h2><blockquote><p>实体必须依靠抽象而不是具体实现。它表示高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象。</p></blockquote><p>简单来说就是程序要依赖于抽象接口，不要依赖于具体实现。要对抽象进行编程，不要对实现进行编程，进而降低客户与实现模块间的耦合。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/9/96/Dependency_inversion.png" alt=""></p><center>图1中，高层对象A依赖于底层对象B的实现；图2中，把高层对象A对底层对象的需求抽象为一个接口A，底层对象B实现了接口A，这就是依赖反转。图片来源：<a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">维基百科</a></center><p>传统的结构化编程中，最上层的模块通常都要依赖下面的子模块来实现，也称为高层依赖低层；DIP 原则就是要逆转这种依赖关系，让高层模块不依赖低层模块，所以称之为依赖倒置原则。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>重构应该是在软件开发过程中无时无刻不在发生的事，当我们在重构之前，不妨先用 UML 图理清楚对象之间的关系，在设计的时候时时记得五大原则，对编写出可读性、稳定性以及可扩展性较高的代码肯定是有帮助的。最关键的软件开发工具是受过良好设计原则训练的思维。</p><blockquote><ul><li>References:</li><li><a href="https://www.jianshu.com/p/4cd95d4ddb59" target="_blank" rel="noopener">https://www.jianshu.com/p/4cd95d4ddb59</a></li><li><a href="https://www.cnblogs.com/olvo/archive/2012/05/03/2481014.html" target="_blank" rel="noopener">https://www.cnblogs.com/olvo/archive/2012/05/03/2481014.html</a></li><li><a href="https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)</a></li><li><a href="https://www.jianshu.com/p/e378025920f8" target="_blank" rel="noopener">https://www.jianshu.com/p/e378025920f8</a></li><li><a href="https://wxs.me/2036" target="_blank" rel="noopener">https://wxs.me/2036</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在项目上经历了一次比较大的重构，把之前不太清晰一些类关系梳理了一下，突然发现 UML 图是个很好用的东西，特此温习一下。顺便复习一下面向对象五大原则，对 clean code 可以说是有很大的帮助。&lt;/p&gt;
&lt;h1 id=&quot;UML-类图&quot;&gt;&lt;a href=&quot;#UML-类
      
    
    </summary>
    
      <category term="Java" scheme="https://www.duyidong.com/categories/Java/"/>
    
    
      <category term="学习" scheme="https://www.duyidong.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="小结" scheme="https://www.duyidong.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="面向对象" scheme="https://www.duyidong.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java系列（四）——类的加载与执行</title>
    <link href="https://www.duyidong.com/2018/02/13/jvm-class-load-and-excute/"/>
    <id>https://www.duyidong.com/2018/02/13/jvm-class-load-and-excute/</id>
    <published>2018-02-13T13:03:40.000Z</published>
    <updated>2018-02-13T09:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>清楚了 JVM 内存结构、GC、类结构，<a href="/2018/02/11/java-class-file-structure/">上篇文章</a>我们知道了字节码是 JVM 实现无关性的重要设计，这篇文章我们来看一下这些字节码文件是如何被虚拟机加载和执行的。</p><h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using) 和 卸载(Unloading)七个阶段。其中准备、验证、解析3个部分统称为连接（Linking），如图所示：</p><p><img src="/images/java_class_lifecycle.jpg" alt=""></p><p>下面我们来一步一步的看类是如何被加载的。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>虚拟机规范则是严格规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><pre><code>- 遇到 new、 getstatic、 putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。- 当使用 JDK1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果REF_getStatic、 REF_putStatic、 REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</code></pre><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。</li><li>通过数组定义来引用类，不会触发此类的初始化。比如SupperClass[] sca = new SupperClass[10];这里不会初始化SupperClass，但是触发了另外一个名为“com.gavin.SuperClass”的类的初始化阶段，它是一个由虚拟机自动生成的，直接继承于Object的子类，创建动作由字节码指令newarray触发。</li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量类的初始化。比如“private static final CONST=”123””,不会引发此类的初始化。</li><li>当一个类在初始化的时候，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父类接口全部完成初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li></ul><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><ul><li><p><strong>加载</strong><br>把存储类的实体从各类介质(文件/网络/数据库/内存中实时生成等)加载到 JVM 内存的方法区中，生成对应对象<code>java.lang.Class</code>。数组类不通过类的加载器创建，而是由虚拟机直接创建，但数组类的元素类型（Element Type）需要类加载器创建。</p></li><li><p><strong>验证</strong><br>为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，，并且不会危害虚拟机的安全，如果验证失败，会抛出 java.lang.VerifyError 异常。验证过程较为复杂，JVM主要验证了class文件格式/java语义限制/java程序逻辑正确性和安全性，其主要技术为<u>静态的字节码分析</u>，所以不能保证100%的可靠。</p></li><li><p><strong>准备</strong><br>为类的<u>静态变量</u>分配内存并初始化为零值，final 则赋真实值，这些变量所使用的内存都将在方法区中进行分配。</p></li><li><p><strong>解析</strong><br>将<u>符号引用</u>（如方法名/变量名/类等等的符号）转化为<u>直接引用</u>（直接指向一块内存区域）的过程,所有符号引用都必须转化为直接引用。</p></li><li><p><strong>初始化</strong><br>在初始化之前，程序已经可以在内存中访问类和它的变量了，这个时候 JVM 会调用类构造器<code>&lt;clinit&gt;()</code>在类被主动引用前，按代码赋初值的计划去给这些变量赋予一个值，它与实例加载时调用的构造器<code>&lt;init&gt;()</code>不同，不需要显示调用父类构造器，而是由虚拟机保证父类<code>&lt;clinit&gt;()</code>已经执行，这也就意味着父类中定义的静态语句优先级要高于子类变量的赋值操作。<br>如果一个类没有静态语句块，也没有对变量的复制操作，编译器可以部位这个类生成<code>&lt;clinit&gt;()</code>方法。<br>接口的<code>&lt;clinit&gt;()</code>是单独执行的，不会受继承和类实现的影响。<br>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被加锁、同步，因此如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时操作，就会造成多个进程阻塞。</p></li><li><p><strong>使用</strong><br>当初始化完成之后，java 虚拟机就可以根据<code>new</code>或反射的调用执行Class的业务逻辑指令，通过堆中java.lang.Class对象的入口地址，调用方法区的方法逻辑，最后将方法的运算结果通过方法返回地址存放到方法区或堆中。</p></li><li><p><strong>卸载</strong><br>参见<a href="/2018/02/09/jvm-gc/">Java系列（二）——JVM内存回收</a>的<a href="https://www.duyidong.com/2018/02/09/jvm-gc/#%E6%96%B9%E6%B3%95%E5%8C%BA%E9%87%8C%E7%9A%84%E7%B1%BB">什么时候回收-方法区里的类</a>部分。</p></li></ul><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p>每当启动一个线程时，JVM 就为它分配一个 Java <strong>栈</strong>，栈是以<strong>栈帧</strong>为单位保存当前线程的运行状态的。栈帧是虚拟机栈的栈元素，每当在调用一个方法时，才为当前方法分配一个帧，然后将该帧压入栈顶，这个帧就成了当前帧，当执行这个方法时，它使用这个帧来存储参数、局部变量，中间计算结果等。线程的切换对应着栈的出栈入栈，线程中的不同方法依次运行对应着帧的出栈和入栈。栈帧的概念结构如图所示：</p><p><img src="/images/jvm_stack_frame.png" alt=""></p><center>图片来源：<a href="https://my.oschina.net/jiangmitiao/blog/483824" target="_blank" rel="noopener">https://my.oschina.net/jiangmitiao/blog/483824</a></center><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧是虚拟机栈的栈元素，栈帧存储了局部变量表，操作数栈，动态连接，返回地址等信息。</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表存储了<u>方法参数</u>以及<u>方法内定义的局部变量</u>。在 Java 程序被编译成 Class 文件时，就在方法的 Code 属性的<code>max_locals</code>数据项中确定了该方法所需分配的最大局部变量表的最大容器。 </p><p>虚拟机通过索引定位的方式使用局部变量表。在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非 static 方法），则局部变量表的第一个索引为该对象的引用，用this可以取到。为了节省栈空间，局部变量表中的变量槽（Variable Slot）是可以重用的。</p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>Java 虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的栈就是操作数栈。操作数栈（Operand Stack），也称操作栈，是一个后入先出（LIFO）栈。同局部变量表一样，操作栈的最大深度也在编译期间写入到 Code 属性的<code>max_stacks</code>中。操作栈最开始为空，由字节码指令往栈中存数据和取数据，也就是出栈入栈动作，方法的返回值也会存到上一个方法的操作数栈中。</p><h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p> 动态连接含有一个指向常量池中该栈帧所属方法的引用，持有该引用是为了进行动态分派。</p><p>在Class文件中存在着大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分在类加载阶段第一次使用阶段的时候转换为直接引用，这种转换称为静态解析。另外一部分将在每次的运行期间转化为直接引用，这部分称为动态转换。</p><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>当一个方法开始执行后，只有两种方式可以退出这个方法，分别是正常返回和异常返回，不管是何种方式退出，退出后都需要返回到方法被调用的位置，程序才能正常执行。</p><ul><li><strong>正常完成出口（Normal Method Invocation Completion）</strong>：当执行引擎遇到任意一个方法返回的字节码指令，是否有返回值和返回值类型依据遇到何种方法返回指令而定。栈帧中会保留调用者的 PC  计数器的值作为返回地址。</li></ul><ul><li><strong>异常完成出口（Abrupt Method Invocation Completion）</strong>：在执行过程中遇到了异常且没有在方法体内处理，不产生返回值，返回地址由异常处理表来确定，栈帧中一般不会有这部分信息</li></ul><p>方法退出时可能执行的操作有：回复上层方法的局部变量表和操作数栈，吧返回值（如果有的话）压如调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后的一条指令。</p><h2 id="关于方法重载"><a href="#关于方法重载" class="headerlink" title="关于方法重载"></a>关于方法重载</h2><p>《深入理解 JVM 虚拟机》这本书中有提到一个关于重载的面试题（题目见<a href="http://allenwu.itscoder.com/poly-in-java" target="_blank" rel="noopener">此处</a>）来解释”确定静态分派的动作实际上不是由虚拟机来执行的“。</p><p>对于代码<code>Human man = new man()</code>而言，Human叫作<strong>静态类型</strong>(外观类型)，Man为<strong>实际类型</strong>，静态类型编译期可知，而实际类型却只有在运行时才能知道。使用哪个重载版本完全取决于传入<strong>参数的数量</strong>和<strong>数据类型</strong>。实例代码中刻意的定义了两个静态类型相同但是实际类型不同的变量，但是JVM在重载时是通过参数的<strong>静态类型（Static Type）</strong>而不是<strong>实际类型（Actual Type）</strong>作为判定依据的。同时静态类型是编译期可知的，因此在编译阶段，Javac 编译器会根据参数的类型来决定选择哪个重载版本，所以在通常情况下重载方法的选择是在编译器由静态分派来决定的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>类的加载和执行构成了 JVM 运行程序的核心，掌握理论知识的同时还需要联系实际看看我们书写的程序是如何在被编译解释和运行的。</p><blockquote><ul><li>References:</li><li><a href="https://gavinzhang1.gitbooks.io/java-jvm-us/content/xu_ni_ji_lei_jia_zai_ji_zhi.html" target="_blank" rel="noopener">https://gavinzhang1.gitbooks.io/java-jvm-us/content/xu_ni_ji_lei_jia_zai_ji_zhi.html</a></li><li><a href="https://segmentfault.com/a/1190000010048751" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010048751</a></li><li><a href="http://www.cnblogs.com/hnlshzx/p/3533264.html" target="_blank" rel="noopener">http://www.cnblogs.com/hnlshzx/p/3533264.html</a></li><li><a href="http://blog.csdn.net/justloveyou_/article/details/72466105" target="_blank" rel="noopener">http://blog.csdn.net/justloveyou_/article/details/72466105</a></li><li><a href="https://my.oschina.net/jiangmitiao/blog/483824" target="_blank" rel="noopener">https://my.oschina.net/jiangmitiao/blog/483824</a></li><li><a href="https://www.jianshu.com/p/1ed1795c9b4a" target="_blank" rel="noopener">https://www.jianshu.com/p/1ed1795c9b4a</a></li><li><a href="https://zhuanlan.zhihu.com/p/31235268" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31235268</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;清楚了 JVM 内存结构、GC、类结构，&lt;a href=&quot;/2018/02/11/java-class-file-structure/&quot;&gt;上篇文章&lt;/a&gt;我们知道了字节码是 JVM 实现无关性的重要设计，这篇文章我们来看一下这些字节码文件是如何被虚拟机加载和执行的。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://www.duyidong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.duyidong.com/tags/Java/"/>
    
      <category term="学习" scheme="https://www.duyidong.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="小结" scheme="https://www.duyidong.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="JVM" scheme="https://www.duyidong.com/tags/JVM/"/>
    
      <category term="Class" scheme="https://www.duyidong.com/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>Java系列（三）——类文件结构</title>
    <link href="https://www.duyidong.com/2018/02/11/java-class-file-structure/"/>
    <id>https://www.duyidong.com/2018/02/11/java-class-file-structure/</id>
    <published>2018-02-11T07:23:44.000Z</published>
    <updated>2018-02-24T15:39:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 的一大成就带来了平台无关性和日益凸显的语言无关性，而字节码（ByteCode）作为语言与平台的“中间代码”，正是构成这种无关性的基石，不同的语言经过各自的编译器编译后形成相同格式的字节码，再被 Java 虚拟机解释为平台相关的机器码并执行，从而实现了一次编写，到处运行（Write Once, Run Anywhere）。</p><p><img src="/images/Jvm_class_loading.png" alt=""></p><center>Java 虚拟机提供的语言无关性，图片来源于网络</center><h1 id="Class-类文件的结构"><a href="#Class-类文件的结构" class="headerlink" title="Class 类文件的结构"></a>Class 类文件的结构</h1><p>Class 文件是一组以 8 位字节为基础单位的二进制流，其本质就是一张表，如下图所示，u1、u2、u4 表示 1 个字节、2 个字节、4 个字节的<strong>无符号数</strong>，无符号数可以用来描述数字、索引引用、数量值或者按照 utf-8 编码构成的字符串值。_info 结尾的表示<strong>表</strong>，用以描述有层次关系的复合结构数据。</p><table><thead><tr><th><strong>类型</strong></th><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>魔数，用以标记文件类型，固定值0xCAFEBABE</td></tr><tr><td>u2</td><td>minor_version</td><td>次版本号，向上兼容</td></tr><tr><td>u2</td><td>major_version</td><td>主版本号</td></tr><tr><td>u2</td><td>constant_pool_count</td><td><strong>常量</strong>的个数</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>常量池，数量为（constant_pool_count - 1）</td></tr><tr><td>u2</td><td>access_flags</td><td>访问标识</td></tr><tr><td>u2</td><td>this_class</td><td>当前类索引</td></tr><tr><td>u2</td><td>super_class</td><td>父类索引</td></tr><tr><td>u2</td><td>interfaces_count</td><td>接口的个数</td></tr><tr><td>u2</td><td>interfaces</td><td>具体的接口内容，数量为 interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td><strong>字段</strong>的个数</td></tr><tr><td>field_info</td><td>fields</td><td>具体的字段内容，数量为 fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td><strong>方法</strong>的个数</td></tr><tr><td>method_info</td><td>methods</td><td>具体的方法内容，数量为 methods_count</td></tr><tr><td>u2</td><td>attribute_count</td><td><strong>属性</strong>的个数</td></tr><tr><td>attribute_info</td><td>attributes</td><td>具体的属性内容，数量为 attributes_count</td></tr></tbody></table><h2 id="常量池（Constant-pool）"><a href="#常量池（Constant-pool）" class="headerlink" title="常量池（Constant pool）"></a>常量池（Constant pool）</h2><p>常量池是Class文件空间最大的数据项之一，长度不固定，主要包含两类：字面量（Literal）和符号引用（Symbolic References），字面量比较接近 Java 语言层面的常量概念，如文本字符串，声明为 final 的常量值等；符号引用这属于编译原理方面的概念，主要包括下面三类常量：</p><pre><code>- 类和接口全限定名(Full Qualified Name)- 字段的名称和描述符(Descriptor)- 方法的名称和描述符</code></pre><p>Java 是在虚拟机加载 Class 文件的时候进行的动态链接，因此 Class 文件不会保存各个方法字段的最终内存布局信息，关于动态链接部分，将在下一篇文章<a href="/2018/02/13/jvm-class-load-and-excute/">Java系列（四）——类的加载与执行</a>介绍。</p><p>常量池中的每一个数据项都有自己的类型，目前 Java 8一共有以下 14 种表结构数据支持不同的常量类型，具体结构可参见<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">官方文档</a>。</p><table><thead><tr><th><strong>常量池中数据项类型</strong></th><th><strong>类型标志</strong></th><th><strong>类型描述</strong></th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码的Unicode字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>int类型字面值</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>float类型字面值</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>long类型字面值</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>double类型字面值</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>对一个类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>String类型字面值</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>对一个字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>对一个类中声明的方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>对一个接口中声明的方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>对一个字段或方法的部分符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标示方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p>可以使用 JDK 提供的 javap 工具，<code>javap -verbose ClassName</code>的方式查看 Class 中的常量。</p><h2 id="访问标志（Access-flags）"><a href="#访问标志（Access-flags）" class="headerlink" title="访问标志（Access flags）"></a>访问标志（Access flags）</h2><p>2个字节代表，标示用于识别一些类或者接口层次的访问信息。</p><table><thead><tr><th>标识名</th><th>标识值</th><th>解释</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>声明为public;可以从包外部访问</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>被声明为final;不允许子类修改</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>当被invokespecial指令调用时，将特殊对待父类的方法</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>接口标识符</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>声明为abstract;不能被实例化</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>声明为synthetic;不存在于源代码，由编译器生成</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>声明为注释类型</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>声明为枚举类型</td></tr></tbody></table><h2 id="类索引、父类索引和接口索引"><a href="#类索引、父类索引和接口索引" class="headerlink" title="类索引、父类索引和接口索引"></a>类索引、父类索引和接口索引</h2><p>类索引（this_class）和父类索引（super_class）都是一个 u2 的数据类型，而接口索引（Interfaces）是一组长度为interfaces_count 的 u2 类型的数据集合，它们的值大多存放的是对常量池中 CONSTANT_Class_info 的引用， Class 文件中由这三项数据来确定这个类的继承关系。</p><h2 id="字段表（Field-info）"><a href="#字段表（Field-info）" class="headerlink" title="字段表（Field info）"></a>字段表（Field info）</h2><p>字段表用于描述类或接口中声明的变量，格式如下：</p><pre><code>field_info {    u2             access_flags; //访问标识    u2             name_index;  //名称索引    u2             descriptor_index; //描述符索引    u2             attributes_count; //属性个数    attribute_info attributes[attributes_count];  //属性表的具体内容}</code></pre><p>字段访问标识如下：(表中加粗项是字段独有的)：</p><table><thead><tr><th>标识名</th><th>标识值</th><th>解释</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>声明为 public; 可以从包外部访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>声明为 private; 只有定义的类可以访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>声明为 protected;只有子类和相同package的类可访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>声明为 static；属于类变量</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>声明为 final; 对象构造后无法直接修改值</td></tr><tr><td><strong>ACC_VOLATILE</strong></td><td>0x0040</td><td>声明为 volatile; 不会被缓存,直接刷新到主屏幕</td></tr><tr><td><strong>ACC_TRANSIENT</strong></td><td>0x0080</td><td>声明为 transient; 不能被序列化</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>声明为 synthetic; 不存在于源代码，由编译器生成</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>声明为enum</td></tr></tbody></table><p>Java语法中，接口中的字段默认包含ACC_PUBLIC, ACC_STATIC, ACC_FINAL标识。ACC_FINAL，ACC_VOLATILE不能同时选择等规则。紧跟其后的name_index和descriptor_index是对常量池的引用，分别代表着字段的简单名和方法的描述符。</p><h2 id="方法表（Method-info）"><a href="#方法表（Method-info）" class="headerlink" title="方法表（Method info）"></a>方法表（Method info）</h2><p>方法表用于描述类或接口中声明的方法，格式如下：</p><pre><code>method_info {    u2             access_flags; //访问标识    u2             name_index;  //名称索引    u2             descriptor_index;  //描述符索引    u2             attributes_count;  //属性个数    attribute_info attributes[attributes_count]; //属性表的具体内容}</code></pre><p>方法访问标识如下：(表中加粗项是方法独有的)</p><table><thead><tr><th>标识名</th><th>标识值</th><th>解释</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>声明为 public; 可以从包外部访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>声明为 private; 只有定义的类可以访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>声明为 protected;只有子类和相同package的类可访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>声明为 static；属于类变量</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>声明为 final; 不能被覆写</td></tr><tr><td><strong>ACC_SYNCHRONIZED</strong></td><td>0x0020</td><td>声明为 synchronized; 同步锁包裹</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>桥接方法, 由编译器生成</td></tr><tr><td><strong>ACC_VARARGS</strong></td><td>0x0080</td><td>声明为 接收不定长参数</td></tr><tr><td><strong>ACC_NATIVE</strong></td><td>0x0100</td><td>声明为 native; 由非Java语言来实现</td></tr><tr><td><strong>ACC_ABSTRACT</strong></td><td>0x0400</td><td>声明为 abstract; 没有提供实现</td></tr><tr><td><strong>ACC_STRICT</strong></td><td>0x0800</td><td>声明为 strictfp; 浮点模式是FP-strict</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>声明为 synthetic; 不存在于源代码，由编译器生成</td></tr></tbody></table><ul><li>对于方法里的Java代码，进过编译器编译成字节码指令后，存放在方法属性表集合中“code”的属性内。</li><li>当子类没有覆写父类方法，则方法集合中不会出现父类的方法信息。</li><li>Java语言中重载方法，必须与原方法同名，且特征签名不同。特征签名是指方法中各个参数在常量池的字段符号引用的集合，不包括返回值。当时Class文件格式中，特征签名范围更广，允许方法名和特征签名都相同，但返回值不同的方法，合法地共存子啊同一个Class文件中。</li></ul><h2 id="属性表（Attribute-info）"><a href="#属性表（Attribute-info）" class="headerlink" title="属性表（Attribute info）"></a>属性表（Attribute info）</h2><p>属性表的基本结构，不同类型的属性表以此为基础各不相同：</p><pre><code>attribute_info {    u2 attribute_name_index;    u4 attribute_length;    u1 info[attribute_length];}</code></pre><p>属性表的限制相对宽松，不需要各个属性表有严格的顺序，只有不与已有的属性名重复，任何自定义的编译器都可以向属性表中写入自定义的属性信息，Java虚拟机运行时会忽略掉无法识别的属性。 关于虚拟机规范中预定义的属性，这里不展开讲了，列举几个常用的。</p><table><thead><tr><th>属性名</th><th>使用位置</th><th>解释</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>方法体的内容</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final关键字定义的常量值</td></tr><tr><td>Deprecated</td><td>类、方法表、字段表</td><td>声明为deprecated</td></tr><tr><td>InnerClasses</td><td>类文件</td><td>内部类的列表</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>Signature</td><td>类、方法表、字段表</td><td>用于支持泛型的方法签名，由于Java的泛型采用擦除法，避免类型信息被擦除后导致签名混乱，Signature记录相关信息</td></tr></tbody></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Class 文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是 Java 技术实现平台无关、语言无关两大特性的重要支柱。</p><p>Class 文件是 Java 虚拟机执行引擎的数据入口，也是 Java 体系技术构成之一。了解 Class 文件的结构对后面进一步了解虚拟机执行引擎有重要的意义。</p><blockquote><ul><li>References:</li><li><a href="http://gityuan.com/2015/10/17/jvm-class-instruction/" target="_blank" rel="noopener">http://gityuan.com/2015/10/17/jvm-class-instruction/</a></li><li><a href="https://my.oschina.net/HeliosFly/blog/356517" target="_blank" rel="noopener">https://my.oschina.net/HeliosFly/blog/356517</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JVM 的一大成就带来了平台无关性和日益凸显的语言无关性，而字节码（ByteCode）作为语言与平台的“中间代码”，正是构成这种无关性的基石，不同的语言经过各自的编译器编译后形成相同格式的字节码，再被 Java 虚拟机解释为平台相关的机器码并执行，从而实现了一次编写，到处运
      
    
    </summary>
    
      <category term="Java" scheme="https://www.duyidong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.duyidong.com/tags/Java/"/>
    
      <category term="学习" scheme="https://www.duyidong.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="小结" scheme="https://www.duyidong.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="Class" scheme="https://www.duyidong.com/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>Java系列（二）——JVM内存回收</title>
    <link href="https://www.duyidong.com/2018/02/09/jvm-gc/"/>
    <id>https://www.duyidong.com/2018/02/09/jvm-gc/</id>
    <published>2018-02-09T15:15:15.000Z</published>
    <updated>2018-02-09T14:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>GC（Garbage Collection 垃圾回收）使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</p><h1 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h1><p>上文<a href="https://www.duyidong.com/2018/01/31/jvm/">JVM内存分配</a>介绍了 JVM 运行时内存分配的各个部分，其中程序计数器、虚拟机栈、本地方法区都是和线程同生共死的，其内存的分配和回收都随着栈帧的进入和退出有序进行，不需要过多考虑回收问题。而 <strong>Java 堆</strong>和<strong>方法区</strong>因为其存放对象和类都是要在运行时才能确认大小，而创建的动作频繁且随机，因此这两部分区域是 GC 关注的主要区域。</p><h1 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h1><h2 id="Java-堆里的对象实例"><a href="#Java-堆里的对象实例" class="headerlink" title="Java 堆里的对象实例"></a>Java 堆里的对象实例</h2><p>Java 堆里存放着 JVM 中几乎所有的对象实例，判断 Stack 中哪些内存可以被回收，首先就得看哪些对象实例已经“死去”，即不可能再被使用。我们先来看两个简单的实现方式：<strong>引用计数算法</strong>发和<strong>可达性分析算法</strong>。</p><h3 id="引用计数算法（Reference-Counting-Collector）"><a href="#引用计数算法（Reference-Counting-Collector）" class="headerlink" title="引用计数算法（Reference Counting Collector）"></a>引用计数算法（Reference Counting Collector）</h3><p>这是在 Python 里被使用的 GC 算法，也是 GC 早期中的早期策略，其实现就是给每一个对象添加一个应用计数器，没有一个地方引用它就加1，当应用失效时就减1，当计数器为0时则说明这个对象不再被使用。这种实现方式简单高效，却有一个比较大的问题导致主流 Java 虚拟机都没有采纳这种方式，就是它无法解决<u>循环引用</u>的问题。例子可见：<a href="http://blog.csdn.net/sunmenggmail/article/details/8172273" target="_blank" rel="noopener">java垃圾回收之循环引用</a>。</p><h3 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h3><p>这种算法是真正被主流商用语言采纳的 GC 算法，其思路是通过通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链（Reference Chain），成为一个树状结构，当所有根节点（GC root）到某个对象都不可达时，则说明这个对象是不可用的。</p><p>有以下几种对象可以被作为 GC Roots:</p><pre><code>- Java Stack 中引用的对象。- 方法区中类静态属性引用的对象。- 方法区中常量引用的对象。- 本地方法中 Native 方法引用的对象。</code></pre><p>值得注意的是，这些不可达对象并不是会立即被清理掉，而是会被进行一次标记，如果该对象覆写了 finalize() 方法且还没有被调用过，则会被放到一个叫 F-Queue 的队列中，这个 finalize 方法原本是用于手动释放非 Java 内存的，但是 JVM 并不一定会执行它；如果在 finalize 方法中对象与引用链上的任一对象发生引用，这个对象就会“起死回生”，在第二次 GC 标记 F-Queue 中对象的时候被移除回收集合。finalize 方法最多只会被执行一次，不确定性大，所以不推荐使用。</p><h4 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h4><p>可达性分析算法中对引用的划分仅限于“引用”和“未引用”，而事实上在程序运行中还有一类“暂时没被引用”的对象，这部分对象我们希望在内存充裕的情况下保留，在内存紧张的时候再将其抛弃。因此在 JDK1.2 后，Java 将引用的概念扩充至强引用（Strong Reference）、软引用（Weak Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference），分别用来描述有用（类似 Object obj = new Object()）、有用但非必须（OOM 前回收）、非必须引用（下一次 GC 回收），以及不影响对象生命周期的引用（用于系统回收通知）。</p><h4 id="如何找到根节点"><a href="#如何找到根节点" class="headerlink" title="如何找到根节点"></a>如何找到根节点</h4><p>由于遍历 GC Roots 节点要求“一致性”，所以 GC 发生的时候需要暂停 Java 执行线程（Sun 称之为”Stop the world”），为了缩短 Stop the world 的时间，遍历根节点时间需要尽可能短，所以 HotSpot 使用了 OopMap 的数据结构来达到这个目的，当程序运行到安全点（Safepoint）的时候，线程的一些状态可以被确定，比如记录OopMap的状态，从而确定GC Root的信息，使JVM可以安全的进行 GC 操作。</p><p>safepoint指的特定位置主要有:</p><pre><code>- 循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)- 方法返回前- 调用方法的call之后- 抛出异常的位置</code></pre><p>安全点存在的意义是为了保证程序不用运行很长时间就可以满足一次 GC 的条件，而如果一些进程休眠或阻塞，则可能长时间无法进入 Safepoint，于是就有了安全区（ Safe region），安全区域是指在一段区域内，对象引用关系等不会发生变化，在此区域内任意位置开始 GC 都是安全的；线程运行时，首先标记自己进入了安全区，然后在这段区域内，如果线程发生了阻塞、休眠等操作，JVM 发起 GC 时将忽略这些处于安全区的线程。当线程再次被唤醒时，首先他会检查是否完成了 GC Roots枚举(或这个GC过程)，然后选择是否继续执行，否则将继续等待 GC 的完成。</p><h2 id="方法区里的类"><a href="#方法区里的类" class="headerlink" title="方法区里的类"></a>方法区里的类</h2><p>方法区（Method Area）对应 Java7 以前的持久代（Permanent generation），已经在 Java8中被移除，取而代之的是使用本地内存的 MetaSpace，其 GC 频率也大幅降低，只有当 MetaSpace 内存达到“MaxMetaspaceSize”值的时候才会触发一次该区域的 GC。根据 JVM 规范，满足以下三个条件的类将被定义为“可以被搜集”：</p><pre><code>- 该类的所有实例都已经被回收。- 加载该类的 ClassLoader 已经被回收。- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</code></pre><p>当然，被标记“可以回收”的类还要视 JVM 的参数（-Xnoclassgc）决定是否被回收。</p><h1 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>在 Hotspot JVM 里，Java 堆采用分代收集（Generational Collection），在了解分代收集之前先来看几种简单的算法：</p><ul><li><strong>标记-清除算法（Mark-Sweep）</strong>：分为“标记”和“清除”两个阶段，将需要清除的内存标记后随即清除，因为绝大部分的对象都只存在很短的时间就需要被收回，这种算法显得很低效；而且会产生大量不连续的存储空间。</li><li><strong>复制算法（Copying）</strong>：按 8:1 的比例划分出一块 Eden 空间和两块 Survivor 空间（S0 和 S1），回收时将 Eden 和 S0 里的内存直接 Copy 到 S1 中，如果 S1 中没有足够的空间，这些对象将通过分配担保（Handle Promotion）机制进入老年代。这种算法的缺点是对对象存活率较高的老年代并不适用。</li><li><strong>标记-整理算法（Mark-Compact）</strong>：与标记清除类似，但标记后并不是直接对可回收对象进行清理，而是先让所有存活对象移向一端，然后直接清理掉端边界以外的内存。</li></ul><p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。</p><p>如图所示，默认情况下新生代和老年占用空间比例为1：2，新生代中Eden:S0:S1=8:1:1，无论什么时候，总是有一块 Survivor 区域是空闲着的，原因后面会讲到。</p><p><img src="/images/JVM_heap.png" alt=""></p><center>图片来自：<a href="https://www.slideshare.net/rgrebski/on-heap-cache-vs-offheap-cache-53098109" target="_blank" rel="noopener">https://www.slideshare.net/rgrebski/on-heap-cache-vs-offheap-cache-53098109</a></center><h2 id="Java-Heap-GC——分代收集"><a href="#Java-Heap-GC——分代收集" class="headerlink" title="Java Heap GC——分代收集"></a>Java Heap GC——分代收集</h2><p>Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>Minor GC 是发生在新生代中的垃圾收集动作，因为 Java 对象大多都具有朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</p><p>新对象在 Eden + S0 中诞生，一旦 Eden 区将满，JVM 会因为申请不到内存触发一次 Minor GC，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳，则使用复制算法将这些仍然存活的对象复制到 S1 区域，然后清理 Edent 和 S0，并将 S0 和 S1 互换，以便执行下一次 GC。年轻代的中的对象每经历一次 Minor GC，对象的年龄会 +1，默认情况下对象年龄达到15（可以通过参数 -XX:MaxTenuringThreshold 来设定），则会被分配到老年代。<br>但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>Full GC 是发生在老年代的垃圾收集动作，常常伴随至少一次的 Minor GC，速度一般比 Minor GC 慢 10 倍以上。 </p><p>较大型的对象会直接进入老年代，另外在年轻代中生存的时间很长的可达对象也会进入Old代，老年代的对象是不容易死掉的，也就意味着 Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。</p><p>另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。</p><h2 id="JVM-参数选项"><a href="#JVM-参数选项" class="headerlink" title="JVM 参数选项"></a>JVM 参数选项</h2><p>jvm 可配置的参数选项可以参考 Oracle 官方网站给出的相关信息：<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></p><p>下面只列举其中的几个常用和容易掌握的配置选项：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小。如：-Xms256m</td></tr><tr><td>-Xmx</td><td>最大堆大小。如：-Xmx512m</td></tr><tr><td>-Xmn</td><td>新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%</td></tr><tr><td>-Xss</td><td>JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。</td></tr><tr><td>-XX:NewRatio</td><td>新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3</td></tr><tr><td>-XX:SurvivorRatio</td><td>新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10</td></tr><tr><td>-XX:PermSize</td><td>永久代(方法区)的初始大小</td></tr><tr><td>-XX:MaxPermSize</td><td>永久代(方法区)的最大值</td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印 GC 信息</td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用</td></tr></tbody></table><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>垃圾收集器是收集算法的具体实现。不同厂商开发的虚拟机有不同的实现方法， HotSpot 包含的七种收集器如图所示：（连线表示可搭配使用）</p><p><img src="/images/Hotspot_JVM_GC_collector.png" alt=""></p><center><strong>图片来自：<a href="http://qsxuan.com/articles/1053.html" target="_blank" rel="noopener">xuan’s blog</a></strong></center><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>实现了用于新生代 GC 的复制算法，古老的单线程收集器，必须停掉所有其他工作线程才能进行，优点是相比其他收集器的单线程简单高效，比较适用于运行于 Client 模式下，需要收集内存比较小，停顿也不会很大的虚拟机。</p><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>Serial 收集器的多线程版，其<strong>并行</strong>的特性使得它在 CPU 数量大于 2 的时候会拥有比单线程更好 GC 性能，同时 ParNew 也是除 Serial 以外唯一能和 CMS 收集器（HotSpot 虚拟机中第一款真正意义的<strong>并发</strong>收集器）配合工作的收集器，因此 ParNew 是许多运行在 Server 模式下虚拟机中首选的新生代收集器。</p><pre><code>名词解释：- 并发(Parallel)：多条 GC 线程并行工作，但此时用户线程仍处于等待状态。- 并发(Concurrent)：用户线程和 GC 线程同时执行(但不一定是并行的，可能会交替执行)，而 GC 程序运行与另一个 CPU 上。</code></pre><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>又一个实现复制算法的新生代多线程收集器， 也被称为“吞吐量优先”收集器。吞吐量是反应的是程序对 CPU 的使用效率，单位时间内 GC 时间越长，吞吐量约低。一般来说 GC 造成的停顿时间越短 GC 频率就会越高，从而使吞吐量下降，但带来的好处是停顿无感，这种策略适用于客户端这种需要和用户直接交互的程序；而高吞吐量的配置是服务器端后台运算所需要的。Parallel Scavenge 收集器提供 -XX:MaxGCPauseMillis 来设置停顿时间，-XX:GCTimeRatio 直接设置吞吐量百分比（运行代码时间/(运行代码时间+单位时间内GC时间)），除此之外还有一个 -XX:+UseAdaptiveSizePolicy 来提供 GC 自适应调整（<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gc-ergonomics.html" target="_blank" rel="noopener">GC Ergonomics</a>）以提供最合适的停顿时间或者最大吞吐量，可以用这种方式搭配前两个参数使用。</p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>用于老年代的单线程收集器，实现了“标记-整理”算法，是 Serial 的老年版，主要用于 Client 端的虚拟机。</p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>用于老年代的多线程收集器，同样实现“标记-整理”算法，是 Parallel Scavenge 的老年版，和 Parallel Scavenge 搭配用于对吞吐量和 CPU 资源敏感的场景非常适用。</p><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS（Concurrent Mark Sweep）是一种以获取最短 GC 停顿时间为目标的收集器，在重视网站响应时间的 Java Web 中使用广泛，实现的是“标记-清除”算法，分为以下几个步骤：</p><ul><li><strong>初始标记（CMS initial mark）</strong>：标记 GC Roots 能直接关联到的对象，速度很快，需要 STW。</li><li><strong>并发标记（CMS concurrent mark）</strong>：进行 Root Tracing 过程，期间用户进程仍在运行。</li><li><strong>重新标记（CMS remark）</strong>：修正并发标记期间变动的标记对象，需要 STW，时间略长于初始标记但远短于并发标记。</li><li><strong>并发清除（CMS concurrent sweep）</strong>:并发执行，不需要 STW。</li></ul><p>CMS 的优点是并发处理、低停顿，缺点是 CPU 数量少的时候性价比不高，且因为无法处理并发清除期间产生的垃圾导致必须要在老年代真正满之前进行 GC。除此之外，CMS 仍然是一款优秀的收集器。</p><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器*"></a>G1 收集器*</h3><p>G1 是未来要替换掉 CMS 成为 JVM 主流收集器的方案，已经被 Java8 设定为默认收集器，其实现思路是将整个 Java 堆划分为多个大小相等的独立区域（Region），将新生代老年代打乱后分配到不同的 Region，各个 Region 单独 GC 从而避免整个 Heap 的扫描，再对 Region GC 价值排序，维护一个优先列表以达到 GC 最高效率。</p><p><img src="/images/G1GC.png" alt=""></p><center><strong>图片来自：<a href="https://blog.idrsolutions.com/2017/05/g1gc-java-9-garbage-collector-explained-5-minutes/" target="_blank" rel="noopener">G1GC – Java 9 Garbage Collector explained in 5 minutes</a></strong></center><p>G1 收集器运作大概分为以下几个步骤：</p><ul><li><strong>初始标记（Initial Marking，STW）</strong>：和 CMS 的初始标记一样，不过除了标记 GC Roots 直接关联的对象之外还会修改 next TAMS（Next Top at Mark Start）的值以求下一个阶段用户新建对象能够被放在正确的 Region。</li><li><strong>并发标记（Concurrent Marking）</strong>：和 CMS 相同，从GC Root开始对heap中的对象标记，标记线程与应用程序线程并行执行，并且收集各个Region的存活对象信息。</li><li><strong>最终标记（Final Marking，STW）</strong>：标记那些在并发标记阶段发生变化的对象，将被回收。</li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong>：清除空Region（没有存活对象的），加入到free list。</li></ul><p>在 G1 收集器中有一个至关重要的数据结构用于处理 Region 之间对象引用的问题，叫做 Remembered Set，简称 RSet，是一种典型的空间换时间的做法，每个 Region 有自己 RSet，记录了谁引用了我的对象，GC 发生时会先检索 RSet，确保不对全栈扫描也不会有遗漏。</p><p><img src="/images/G1_Collector.png" alt=""></p><center><strong>G1 收集器运行示意图 - 图片来自网络</strong></center><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>内存回收与垃圾搜集很多时候是影响系统性能、并发能力的主要原因，深入了解 JVM  GC 机制有助于性能调优和理解如何编写高性能代码。</p><blockquote><ul><li>References:</li><li><a href="http://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="noopener">聊聊JVM（六）理解JVM的safepoint</a></li><li><a href="http://www.blogjava.net/fancydeepin/archive/2013/09/29/jvm_heep.html" target="_blank" rel="noopener">Java 堆内存</a></li><li><a href="https://mritd.me/2016/03/24/HotSpot-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">HotSpot 虚拟机的算法实现</a></li><li><a href="https://yq.aliyun.com/articles/52426" target="_blank" rel="noopener">Jvm原理剖析与调优之内存结构</a></li><li><a href="http://www.infoq.com/cn/articles/jdk7-garbage-first-collector" target="_blank" rel="noopener">解析JDK 7的Garbage-First收集器</a></li><li><a href="https://tech.meituan.com/g1.html" target="_blank" rel="noopener">Java Hotspot G1 GC的一些关键技术*</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GC（Garbage Collection 垃圾回收）使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="Java" scheme="https://www.duyidong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.duyidong.com/tags/Java/"/>
    
      <category term="学习" scheme="https://www.duyidong.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="小结" scheme="https://www.duyidong.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="JVM" scheme="https://www.duyidong.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java系列（一）——JVM内存分配</title>
    <link href="https://www.duyidong.com/2018/01/31/jvm/"/>
    <id>https://www.duyidong.com/2018/01/31/jvm/</id>
    <published>2018-01-31T00:57:05.000Z</published>
    <updated>2018-02-09T14:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>成都近日气温已逾零下。让我想起在赤峰拍戏的日子，八月凌晨三点，茶水车结出一道冰溜子，18 个人抢 8 件军大衣，有人要去扒箱车，制片大喊：“别动！那是给领导穿的” —— 生活如此不易。如今我更加体会到“平凡的生活也要靠努力去争取”。</p><h1 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM"></a>什么是 JVM</h1><p>JVM（Java Virtual Machine Java 虚拟机）是一种用于计算设备的规范，基于这套规范，许多团队开发了多种<a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines" target="_blank" rel="noopener">不同的虚拟机实现</a>，目前使用范围最广的是从 Sun 公司开始，到 Oracle 后一直在使用 的 HotSpot 以及 <a href="http://openjdk.java.net/" target="_blank" rel="noopener">Open JDK</a>，二者一个由 Oracle 公司维护，一个由开源社区维护，使用起来并没有太大差别。</p><pre><code>$java -versionjava version &quot;1.8.0_91&quot;Java(TM) SE Runtime Environment (build 1.8.0_91-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)</code></pre><h1 id="名词释义"><a href="#名词释义" class="headerlink" title="名词释义"></a>名词释义</h1><p><strong>JRE</strong>(JavaRuntimeEnvironment，Java运行环境)，包含了 Java API 类库中的 Java SE API 子集和 Java 虚拟机两部分，所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。</p><p><strong>JDK</strong>(Java Development Kit) 包含了 Java 程序设计语言、 Java 虚拟机、Java API 类库三部分，是支持 Java 程序开发的最小环境，包含了开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。</p><p><strong>JVM</strong> 是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。</p><p><strong>Java SE</strong>（Standard Edition）Java 标准版，提供完整的 Java  核心 API，我们通常在 Oracle 下载的 JDK 全称就是“Java SE Development Kit”。</p><p><strong>Java EE</strong> （Enterprise Edition）Java 企业版，包含了 Java SE 并增加了附加类库，Java EE是以Java SE为基础的。所以并没有“JVM for Java EE”这么一说，只有“JVM for Java SE”，可以用于Java SE与Java EE。</p><p><img src="/images/Java_Tech.png" alt=""></p><center> <strong>Java 技术体系包含的内容</strong> 图片来自：<a href="https://docs.oracle.com/javase/8/docs/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/</a></center><h1 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h1><p>根据 <a href="https://files.cnblogs.com/files/zhuYears/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%EF%BC%88JavaSE7%EF%BC%89.pdf" target="_blank" rel="noopener">Java 虚拟机规范</a>（<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">最新版</a>）规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示：</p><p><img src="/images/JVM_architecture.png" alt=""></p><p><strong>程序计数器（Program Counter Register）</strong>: 可以看作是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。PC Register 是线程私有的内存，每个线程的计数器是独立存储的，如果线程执行的是一个 Java 方法，这个计数器记录的就是正在执行的虚拟机字节码地址，方便线程在 CPU 中切换后能够恢复在切换之前的程序执行位置，并且不能互相被干扰。如果正在执行的是 Native 方法，则计数器为空。</p><p>由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p><p><strong>Java 虚拟机栈（Java Virtual Machine Stacks ）</strong>是Java方法执行的内存模型，有着和线程相同的生命周期，每一个方法从调用到完成，都对应着一个栈帧（Stack Frame）在虚拟机中入栈到出栈的过程，栈帧用于局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(ReturnAddress)和一些额外的附加信息。</p><ul><li>局部变量表是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。</li><li>操作数栈也常被称为操作栈。和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作—压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。程序中的所有计算过程都是在借助于操作数栈来完成的。</li><li>指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。</li><li>方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。</li></ul><p>由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。</p><p>当线程请求的栈深度大于虚拟机允许的深度，将抛出 StackOveflowError；<br>当虚拟机扩展时也无法申请到足够的内存，将抛出 OutOfMemoryError.</p><p><strong>本地方法栈（Native Method Stack）</strong>用于执行 Java 方法以外的本地方法，没有过多限制，由虚拟机自由实现。Sun HotSpot VM 就把 Native Method Stack 和 VM Stack 合二为一。<br>和 JVM Stack 一样，Native Method Stack 也有 OutOfMemoryError 和 StackOverflowError 两个 Error。</p><p><strong>Java 堆（Java Heap）</strong>存放几乎所有的对象实例，也是 GC（Garbage Collection）发生的主要区域，被所有线程共享。因为 GC 的需求，Heap 可以再被细分为新生代和老年代（这一部分在<a href="/2018/02/09/jvm-gc/">Java系列（二）——JVM内存回收</a>中有涉及），但是与其储存的内容无关。Java Heap 应该可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。Heap 既可以固定大小也可以动态扩展。在 JVM 中只有一个堆。<br>如果 Heap 中没有内存完成实例分配，且堆无法再扩展，则会抛出 OutOfMemoryError。</p><p><strong>方法区（Method Area）</strong>用于存放类信息、常量、静态变量等数据，结构上和 Heap 一致，功能上却要加以区分。在 Java8 以前，这块区域对应的是 GC 的“永久代”（Permanent Generation），java8 后被更名为“元空间”（MetaSpace）。</p><p>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。当方法区无法满足内存需求时会抛出 OutOfMemoryError 异常。</p><p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分，用于存放编译期生成的各种字面量和符号。避免了频繁的创建和销毁对象而影响系统性能，实现了对象的共享，节省了内存空间和运行时间。值得说明的是，运行时常量池具备动态特性，常量不止在编译期可以产生，在运行期间也可以产生，比如String的intern方法。</p><h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><ol><li>在常量池中检查是否已有该类的符号引用，并检查该类是否已初始化，如果没有则需要加载该类。</li><li>在 Heap 中为对象分配内存：指针碰撞（Bump the Pointer）、空闲列表（Free List），取决于 Java 堆是否规整；除此之外出于虑线程安全的考虑，使用 CAS（Compare and Swap）和失败重试的方式保证操作的原子性。也可以用 TLAB（Thread Local Allocation Buffer），即预先给线程匹配缓冲内存的方式实现。</li><li>内存分配完成后，虚拟机会将该部分内存除了头以外的空间初始化为零，这就是为什么 Java 中的对象可以不赋初值就使用。</li><li>对对象头进行设置，如这个对象是属于哪个类的实例、如何才能找到类的元数组信息、对象哈希码、 GC 分代年龄、锁状态标志等信息。</li><li>执行完 new 之后会接着执行 init 方法，把对象按照程序员的意愿初始化，一个真正可用的对象才算完全被初始化出来。  </li></ol><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><ul><li><strong>对象头</strong>（Header）<br>  第一部分：用于存储对象自身的运行时数据，成为“Mark Word”，被设计为一个非固定结构的数据结构，它会根据对象的状态复用自己的存储空间。<br>  第二部分：类型指针，用于指向它的类元数据③，虚拟机能通过这个指针确定这个对象是哪个类的实例。（非必须）</li><li><strong>实例数据</strong>（Instance Data）<br>  程序代码中定义的各种类型字段内容。HotSpot 虚拟默认分配策略是等长字段分配到一起，从父类继承来的变量在子类之前，子类变量较窄的值也可能插入到父变量的空隙中。</li><li><strong>对齐填充</strong>（Padding）<br>  占位符（非必须）。填满8字节的整数倍。</li></ul><h2 id="关于锁"><a href="#关于锁" class="headerlink" title="关于锁"></a>关于锁</h2><p>独占锁是一种<strong>悲观锁</strong>，synchronized就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是<strong>乐观锁</strong>。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><h1 id="对象定位"><a href="#对象定位" class="headerlink" title="对象定位"></a>对象定位</h1><p>Java 对象的使用是通过 Stack 的 reference 数据来操作的，通常的实现方式有两种：使用句柄 和 直接指针。</p><ul><li>句柄访问：Java 堆中将分配一块句柄池，用于 Map 句柄地址和对象实例以及类型数据的指针，这种方式 Reference 里保存的信息就是句柄地址。</li><li>指针访问：Reference 中储存的是 Java 堆中对象的地址，这个对象中就要考虑如何放置类型数据相关的信息，这部分信息在方法区里。</li></ul><p>句柄访问的好处在于可以灵活应对对象被移动的情况而不需要改变 Stack 里的 Reference，缺点是维护多一个表增大了时间上的开销，所以 Sun HotSpot 使用直接指针的方式进行对象访问。</p><blockquote><ul><li><strong>References：</strong></li><li><a href="https://www.jianshu.com/p/18fbb32f17b6" target="_blank" rel="noopener"> JVM类型与模式[java -version]</a></li><li><a href="https://www.jianshu.com/p/28639d7a00fe" target="_blank" rel="noopener">https://www.jianshu.com/p/28639d7a00fe</a></li><li><a href="https://www.zhihu.com/question/29265430" target="_blank" rel="noopener">https://www.zhihu.com/question/29265430</a></li><li><a href="https://yq.aliyun.com/articles/52426" target="_blank" rel="noopener">阿里云栖社区：Jvm原理剖析与调优之内存结构</a></li><li><a href="https://blog.brucefeng.info/post/jvm-architecture" target="_blank" rel="noopener">JVM结构</a></li><li><a href="https://www.jianshu.com/p/c7f47de2ee80" target="_blank" rel="noopener">https://www.jianshu.com/p/c7f47de2ee80</a></li><li><a href="http://blog.csdn.net/aesop_wubo/article/details/7537960" target="_blank" rel="noopener">JAVA并发编程学习笔记之CAS操作</a></li><li><a href="http://www.cnblogs.com/Mainz/p/3546347.html" target="_blank" rel="noopener">非阻塞同步算法与CAS(Compare and Swap) 无锁算法</a></li><li><a href="http://www.importnew.com/20472.html" target="_blank" rel="noopener">乐观锁的一种实现方式——CAS</a></li><li><a href="http://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">java 中的锁 – 偏向锁、轻量级锁、自旋锁、重量级锁*</a></li><li><a href="https://yq.aliyun.com/articles/280800" target="_blank" rel="noopener">玩转JVM虚拟机：JVM内存结构</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;成都近日气温已逾零下。让我想起在赤峰拍戏的日子，八月凌晨三点，茶水车结出一道冰溜子，18 个人抢 8 件军大衣，有人要去扒箱车，制片大喊：“别动！那是给领导穿的” —— 生活如此不易。如今我更加体会到“平凡的生活也要靠努力去争取”。&lt;/p&gt;
&lt;h1 id=&quot;什么是-JVM&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://www.duyidong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.duyidong.com/tags/Java/"/>
    
      <category term="学习" scheme="https://www.duyidong.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="小结" scheme="https://www.duyidong.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="JVM" scheme="https://www.duyidong.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>细说HTTPS</title>
    <link href="https://www.duyidong.com/2018/01/26/about-HTTPS/"/>
    <id>https://www.duyidong.com/2018/01/26/about-HTTPS/</id>
    <published>2018-01-26T01:41:27.000Z</published>
    <updated>2018-02-09T14:45:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近客户公司经历了一次大的证书升级，内网许多服务之间的调用出现了证书过期或是不授信的问题。前面我写过两篇文章介绍<a href="https://www.duyidong.com/2016/03/30/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">HTTP协议</a>以及<a href="https://www.duyidong.com/2016/04/17/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E4%BA%8B%E5%8A%A1%E6%98%AF%E6%80%8E%E6%A0%B7%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%EF%BC%9F/">一次完整的HTTP事务是怎样一个过程</a>，这篇文章主要介绍一个大家日常工作中都在打交道但却不一定很熟悉的协议 —— HTTPS。</p><h1 id="名词澄清"><a href="#名词澄清" class="headerlink" title="名词澄清"></a>名词澄清</h1><p>HTTPS 服务是工作在 SSL/TLS 上 的HTTP。</p><p>首先简单区分一下 HTTPS，SSL ，TLS ，OpenSSL 这四者的关系：</p><ol><li>SSL：（Secure Socket Layer，安全套接字层）是在客户端和服务器之间建立一条SSL安全通道的安全协议；</li><li>TLS：（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性；</li><li>TLS的前身是SSL；</li><li>OpenSSL是TLS/SSL协议的开源实现，提供开发库和命令行程序；</li><li>HTTPS是HTTP的加密版，底层使用的加密协议是TLS。</li></ol><p>结论：SSL/TLS 是协议，OpenSSL是协议的代码实现。Sun HotSpot 的 jdk 中提供了一个叫 keytool 的工具，有和 openssl 差不多的功能。</p><h1 id="为什么我们需要-HTTPS"><a href="#为什么我们需要-HTTPS" class="headerlink" title="为什么我们需要 HTTPS"></a>为什么我们需要 HTTPS</h1><p>根据<a href="www.ruanyifeng.com/blog/2014/02/ssl_tls.html">阮一峰的SSL/TLS协议运行机制的概述</a>，HTTP 通信有三大风险：</p><pre><code>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。（2） 篡改风险（tampering）：第三方可以修改通信内容。（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</code></pre><p>为了解决这些问题，1994年 NetScape 公司设计了 SSL 协议（Secure Sockets Layer）的1.0版，并在 1996 年得到大规模应用，1999年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS。HTTPS 在 HTTP 的基础上做到了两点：<strong>加密（Encrypt）</strong>和<strong>认证（Verification）</strong>。</p><h1 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h1><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>HTTPS 的基本思路是采用<a href="https://baike.baidu.com/item/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">非对称加密</a>，服务器用私钥加密信息，客户端使用公钥解密，反之亦然。公钥由服务器提供，在客户端第一次请求时返回给客户端。但是这样做有两个显而易见的问题，一是因为公钥是容易获取的，任何一个客户端只要得到了公钥就可以解密传输的信息，这样做并不安全；二是非对称加密加解密速度要远远慢于对称加密，在某些极端情况下，甚至能比对称加密慢上1000倍。</p><p>正因为此，TLS 采用在客户端和服务器次握手间的三个随机数生成<strong>“对话秘钥”</strong>，采用对称加密加密传输信息，如下图所示：</p><p><img src="/images/SSL_handshake.png" alt=""></p><center><strong>图片来自：<a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">Cloudfare</a></strong></center><ol><li>在 TCP 握手完成后，客户端向服务器发送一个请求（ClientHello），携带信息包括支持协议版本（TLS 1.0）、加密方式（RSA）、压缩方法，以及一个客户端生成随机数。</li><li>服务器确认使用的通信协议，如果不支持则关闭加密通信，如果支持则回应客户端请求（ServerHello），发送包括确认加密算法、压缩算法、服务器公钥，以及一个服务器端生成随机数。</li><li>客户端在收到服务器确认连接的响应后，会生成第三个随机数（被称为“pre-master key”），使用上一个请求返回的公钥加密后发送给服务器。（这样做是为了方式握手期间被第三方监听），并提供前面握手的内容的 hash 值表示客户端握手结束，并用于服务器端校验。</li><li>服务器端在收到客户端加密后的随机数后用私钥解密。这个时候，客户端和服务器端都同时拥有了三个在一次会话中生成的完全相同的三个随机数：客户端生成随机数、服务器端生成随机数、Pre-master key。随即客户端和服务器端用这三个数生成同一把<strong>会话密钥</strong>（Session key），用于加密随后通信的信息。介时，服务器端还会向客户端返回一个编码变更通知表示服务器会话结束，并提供一个前面会话的 hash 值用于客户端校验。</li><li>客户端与服务器端开始对称加密通信。</li></ol><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>可以想象，即使做到了客户端和服务器之间通信的保密性，并不意味着就不会有人来冒充服务器端响应客户端的请求。参照网络七层协议，互联网中的设备通信只能够靠 IP 来标示对方，而因为 IP 不便记忆所以我们有了 DNS（Doman Name Service），域名和 IP 的映射除了靠 DNS 服务器记录之外还会有限去查询本地缓存，如果本地 DNS 映射的缓存被攻击者更改就会造成 DNS 劫持，许多钓鱼网站就是利用这个方式将一个域名指向的 IP 改变为钓鱼网站的服务器 IP，再做一个和官方网站一模一样的网站骗走用户的隐私信息。因此，如何确认客户端现在连接的服务器就是真正的目标服务器就变得十分重要。</p><p>要达到这个效果就要求官方网站必须去一个中心备案，客户端每次在连上服务器开始会话之前先去这个中心查阅一下该网站是不是真的就是浏览器上这个域名对应的网站，验证通过后才建立连接。这个“中心”就是 CA （Certificate Authority 证书授权中心），用于查阅校验的文件就是“证书（Certificate）”。</p><p>这个过程中涉及到两个步骤，一个是证书的签发（Signing），一个是证书的验证（Verification），如下图所示：</p><p><img src="/images/Certificate_Signing_and_Verification.png" alt=""></p><center><strong>图片出自：<a href="https://www.pianyissl.com/support/page/10" target="_blank" rel="noopener">什么是数字证书的证书链</a></strong></center><p>证书的签发：证书签发机构将服务器提供的数据经过一次 [Hash] 用 CA 的秘钥加密，再附到证书中，成为办法给服务器的证书。拿到证书的服务器会在第一次响应服务请求（ServerHello）的时候将证书发送给客户端，客户端拿到这个证书后会去请求证书签发机构，这个时候签发机构就会拿这个证书的 Hash 值和已存的证书 Hash 值对比，如果一致，则认证通过，如果不一致，你就会在流量器里看到你访问的网站不受信的错误提示，提醒用户小心访问。</p><p>除此之外，证书的认证还有一个细节，就是证书链：</p><p><img src="/images/certificate_chain.png" alt=""></p><center><strong>图片出自：<a href="https://www.pianyissl.com/support/page/10" target="_blank" rel="noopener">什么是数字证书的证书链</a></strong></center><p>一个网站的证书通常分为三级：根证书（root），中间证书（intermediate），终端证书（end-user），当用户拿到一个网站的证书，是 End-user，他会先去找这个证书 CA 的证书的颁发者（intermediate）认证 CA 的域名是否授信，intermediate 可能有很多层，最后会认证到 Root，Root 证明 intermediate 是授信的，intermediate 证明 End-user 是授信的，最后再由最后一级 CA 证明这个网站的域名是授信的。</p><p>总上所述，一次完整的 HTTPS 连接的建立，加上证书验证，应该是这样的：</p><p><img src="/images/HTTPS_handshake.png" alt=""></p><p>关于这张图片的相信描述，可以参考：<a href="http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html" target="_blank" rel="noopener">图解HTTPS</a></p><h1 id="自签证书"><a href="#自签证书" class="headerlink" title="自签证书"></a>自签证书</h1><p>根证书没有上层机构再为其本身作数字签名，所以都是<strong>自签证书</strong>，操作系统以及浏览器会预先安装可被信任的根证书，这代表用户授权了应用软件代为审核哪些根证书机构属于可靠，很多企业内部出于安全都会有内网 HTTPS 的需求，就涉及到证书自签名和授信。这里有一个完整的<a href="https://yi-love.github.io/blog/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/2017/07/15/https-ca.html" target="_blank" rel="noopener">教程</a>教你如何搭建一个包含自签名证书的网站，归纳一下大致分为这五步：</p><pre><code>1. 准备 CA 机构所需资质：ca.key (CA机构私钥) -&gt; ca.csr（Cerificate Signing Request， CA机构请求文件） （带机构信息）2. CA 机构申请证书： ca.key + ca.csr -&gt; ca.crt（CA 机构证书） 3. 服务器准备申请所需资质：server.key -&gt; server.csr （带机构信息）4. CA 机构颁发给网站证书：ca.crt + ca.key + v3.ext (附带文件，记录网站有关信息) + server.csr = server.crt 5. 客户端安装CA证书：把 ca.crt 添加到 keystore</code></pre><h1 id="如何部署和升级"><a href="#如何部署和升级" class="headerlink" title="如何部署和升级"></a>如何部署和升级</h1><p>作为面向终端用户提供服务的服务器，需要两个文件：certificate.crt 和 server.key，certificate.crt 用于向客户端发送证书及公钥，server.key 用以解密 pre-master key。以 Apache 为例，需要在配置文件中加入：（完整配置参照<a href="https://httpd.apache.org/docs/2.4/ssl/ssl_howto.html" target="_blank" rel="noopener">这里</a>）</p><pre><code>SSLCertificateFile &quot;/path/to/certificate.crt&quot;SSLCertificateKeyFile &quot;/path/to/server.key&quot;</code></pre><p>对于后端应用，除了提供 HTTPS 服务器的角色往往还会充当客户端的角色，因此就需要把调用服务的证书 CA.crt 加入到自己的授信列表中。以 Java 为例，你需要关注 <strong>KeyStore</strong> 和 <strong>TrustStore</strong>：<br>从文件格式上来看，KeyStore 和 KeyStore 其实是一个东西，只是为了方便管理将其分开；Keystore可以看成一个放 key 的库，key 就是公钥，私钥，数字签名等组成的一个信息，TrustStore 中保存的是一些可信任的证书，主要是 java 在代码中访问某个 https 的时候用于对被访问者进行认证的，以确保其实可信任的。TrustStore 是必须的，如果我们没有显式的指定，那么 java 会默认指定为 $JAVA_HOME/lib/security/cacerts 这个文件。</p><p>如果要指定的话，可以在java的参数中进行指定：</p><pre><code>-Djavax.net.ssl.keyStore=clientKeys   -Djavax.net.ssl.keyStorePassword=password   -Djavax.net.ssl.trustStore=clientTrust   -Djavax.net.ssl.trustStorePassword=password</code></pre><p>Springboot 类似，参照<a href="https://howtodoinjava.com/spring/spring-boot/spring-boot-ssl-https-example/" target="_blank" rel="noopener">Spring Boot SSL [https] Example</a>。</p><p>在实际使用过程中，TrustStore 也可以被导入到 KeyStore 中成为一个文件，不过往往会有两份，一个作为 TrustStore，一个作为 KeyStore。</p><h1 id="关于各式各样的证书格式"><a href="#关于各式各样的证书格式" class="headerlink" title="关于各式各样的证书格式"></a>关于各式各样的证书格式</h1><p>前面我们已经提到 csr（请求文件）、key （私钥文件）、jks（KeyStore文件）、crt（证书文件）几种文件类型，但我们往往还会看到证书有关的 <em>.pem, </em>.crt, <em>.ca-bundle, </em>.cer, <em>.p7b, </em>.p7s 这些文件后缀名，这些文件其实都是一个或多个证书练的压缩格式，例如 p7b 格式的文件可以在 windows 平台下展开看到证书链，并且可以直接安装在 windows 系统中。不同格式的证书包是可以互相转换的，参见：<a href="https://support.ssl.com/Knowledgebase/Article/View/19/0/der-vs-crt-vs-cer-vs-pem-certificates-and-how-to-convert-them" target="_blank" rel="noopener">DER vs. CRT vs. CER vs. PEM Certificates and How To Convert Them</a></p><blockquote><ul><li>Reference: </li><li><a href="https://yi-love.github.io/blog/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/2017/07/15/https-ca.html" target="_blank" rel="noopener">https://yi-love.github.io/blog/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/2017/07/15/https-ca.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></li><li><a href="https://www.pianyissl.com/support/page/10" target="_blank" rel="noopener">https://www.pianyissl.com/support/page/10</a></li><li><a href="https://support.dnsimple.com/articles/what-is-ssl-certificate-chain/" target="_blank" rel="noopener">https://support.dnsimple.com/articles/what-is-ssl-certificate-chain/</a></li><li><a href="http://blog.csdn.net/chenzanlong123/article/details/11784143" target="_blank" rel="noopener">http://blog.csdn.net/chenzanlong123/article/details/11784143</a></li><li><a href="https://helpdesk.ssls.com/hc/en-us/articles/204093372-What-are-certificate-formats-and-what-is-the-difference-between-them-" target="_blank" rel="noopener">https://helpdesk.ssls.com/hc/en-us/articles/204093372-What-are-certificate-formats-and-what-is-the-difference-between-them-</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近客户公司经历了一次大的证书升级，内网许多服务之间的调用出现了证书过期或是不授信的问题。前面我写过两篇文章介绍&lt;a href=&quot;https://www.duyidong.com/2016/03/30/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A
      
    
    </summary>
    
      <category term="学习总结" scheme="https://www.duyidong.com/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="HTTPS" scheme="https://www.duyidong.com/tags/HTTPS/"/>
    
      <category term="HTTP" scheme="https://www.duyidong.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>再见 2017， 你好 2018</title>
    <link href="https://www.duyidong.com/2017/12/28/goodbye-2017-hello-2018/"/>
    <id>https://www.duyidong.com/2017/12/28/goodbye-2017-hello-2018/</id>
    <published>2017-12-28T08:30:29.000Z</published>
    <updated>2018-02-22T13:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2017-commit-github-yidong.png" alt=""></p><center><strong>2017年我的 github commit</strong></center><p>伴随着支付宝红包羊毛党铺天盖地的短信，本命年也在忙碌的十二月底宣告接近尾声。过去的一年，我似乎成为了一个还不错的程序员，同事们的互评中出现了“快速学习”、“努力”、“DevOps专家”这些词以示认可，在自我认识中也渐渐意识到自己已经走入了在公司的一个舒适区，也许是过去一年都待在海外交付项目上的缘故，项目上的事情总是忙一阵闲一阵，还好公司的事情和自己的学习计划从来没有中断过。</p><h1 id="云计算红红火火"><a href="#云计算红红火火" class="headerlink" title="云计算红红火火"></a>云计算红红火火</h1><p>漫长的上半年，我一直在一个“大型跨国金融保险企业-架构师团队”做开发，日常工作基本是和客户开会和发邮件，线上 debug 的能力练就了不少，遗憾的是鲜有时间写代码。在此期间，云计算一度被炒的很火，我的股票断断续续涨了24%，期间也在抽空准备考取 <a href="/2017/04/05/How-to-pass-the-aws-certification/">AWS 助理架构师认证</a>，算是赶上了又一波云计算的大潮。在这个项目组期间因为种种原因我一直不是很开心，一方面是因为日常工作太琐碎目标不明确，另一方面团队长期只有一两个人而没有归属感。那段时间我几乎每天都去游泳，在泳池交织的浪花和水底的静谧中思考着未来的种种可能。也是在一次游泳的时候，经博文的指点及时调整了心态，认真对待每一份到手的工作，在频繁的沟通中大幅提升了英文能力，在琐碎的工作中打磨自己的 DevOps 技能，并在下项目后将团队中的一系列实践和感受总结成文，（见：<a href="http://insights.thoughtworks.cn/what-does-the-devops-team-has-delivered/" target="_blank" rel="noopener">《DevOps 之殇》</a> ），得到了公司和同事们的认可。更开心的是，我利用工作之余的时间学习并拿到了<a href="https://s3.amazonaws.com/duyidong-archive/pdf/awsSolutionsArchitect_AE.pdf" target="_blank" rel="noopener">云计算能力的证明</a>，这份证明为后来我争取到很多接触其他项目的机会，也让我得到了比在同一个项目上的同事更多的锻炼。</p><h1 id="DevOps-没有死"><a href="#DevOps-没有死" class="headerlink" title="DevOps 没有死"></a>DevOps 没有死</h1><p>还记得公司群里一句“DevOps已死”，让刚一脚迈进云计算大门的我措手不及，“DevOps 已经开始被平台取代，我司未来的咨询方向将是人工智能，大数据，区块链”这是我当时听到的话。</p><p>在我看来选择公司最重要的就是和自己的发展目标一致，那我现在最擅长的领域将被技术革命，是不是意味着我必须要换个方向？于是我抬头，四顾枉然：AI 对数学的要求很高，而我数学成绩并不是很好；大数据不错，但目前似乎缺少立项机会；区块链听着挺牛的，是不是该学一学呢？技术方向的选择让我迷茫了好一阵子，又被忙碌的下半年冲淡了。其实回过头来看当时的想法，才发现 <strong>DevOps 并没有死，而是化作了 CICD、化作了微服务、化作了 DPS 数字化平台战略。</strong>PaaS 也许会取代 DevOps 里的诸多实践，但 DevOps 所提倡的“为最终交付价值负责”的产品思维，将继续无处不在地影响着我们的日常交付。</p><p>这么一想，我似乎更理解了咨询的意义。</p><h1 id="比特币暴涨"><a href="#比特币暴涨" class="headerlink" title="比特币暴涨"></a>比特币暴涨</h1><p><img src="/images/2017-bitcoin-price.png" alt=""></p><center><strong>2017年疯涨的比特币</strong></center><p>风风火火的五月，记忆中是节节攀高的比特币市价，和比特币一样高涨的是我的工作负荷。</p><p>我是在项目决定使用 Openshift 的第二天注意到邮件的，紧接着就得到要在公司开展 Openshift 培训的机会。接下来把手里的 Workshop 和 Session 交给新人，又拉来了两位同事，开始了为期两周日夜兼程的学习。现在看来真是性价比极高的两个周，不但弄清楚了 K8s 的底层架构，连之前自以为已经很熟悉的 Docker 也从头到尾重新学了一遍，最后如期交付了 Workshop ，也为后来公司围绕能力建设开展的一系列活动做好充分的准备。</p><p>六月底，我终于从架构师黑工团队被转移到了一个开发团队，维护一个 2c 应用。从进公司起，我就一直在各种设计理念和流程优化中摸爬滚打，在邮件和文档中贡献着自己的知识，现如今终于有一个机会可以给我写代码，自然是十分开心的。从前端到后端，从 React 到 Springboot，我开始给自己制定了一个又一个计划，虽然最终因为繁忙的社区活动没能善终，不过体验 TDD 和敏捷开发流程的愿望算是得到了满足。</p><p>下半年参加了很多活动，从电子科大交流月给学弟们讲云计算，到去 AWS 讲 Serverless，大大小小五六个分享让我每周都处于很忙的状态，加上新上项目的压力，在公司的时间已经延伸到十二点以后。然而这段时间状态并不是特别好，深感工作和生活失去平衡。也不是每个 session 效果都好，而且大部分分享缺少善后总结。可见工作效率是不能靠加班加出来的。</p><p>十月，参加了公司校招面试；十一月，在项目上技术栈熟悉之后改良了一把 CICD；12 月，17年就已经接近尾声了。</p><blockquote><p>过去的一年学习教会我看到了产品而不只是代码，那么下一年我对自己的要求应该是看到“团队”。</p></blockquote><h1 id="社区运营"><a href="#社区运营" class="headerlink" title="社区运营"></a>社区运营</h1><p><img src="/images/2017-cloud-and-devops-commity.jpeg" alt=""></p><center><strong>成都 Cloud &amp; DevOps community 社区活动合影</strong></center><p>18年对我来说比较有挑战性的一件事就是承担起成都 Cloud &amp; DevOps 社区运营的职责，在过去我一直是一个高输出的贡献者，偶尔喜欢发发牢骚。从成员到社区服务者的角色转变，就好比在台下振振有词的观众，突然被一只大手拉上台，面对台下的观众却结结巴巴不知道说什么，连续几周都是一脸懵逼的状态：我连自己的发展方向都没想好，更别说社区未来的发展方向。不过最近我开始渐渐意识到，这是一次走出舒适区的机会，是对我组织沟通能力的一次考验。既然我可以用自己的学习方法快速获取各种技能，那为什么不能把社区运营作为一种技能去学习？</p><h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><blockquote><p>过去我沉浸在自己的节奏和自己的认知闭环中，未来希望我能更多为别人着想，有更开阔的心胸和从容的心态。</p></blockquote><p>明年希望自己在以下几个方面能有所提升：</p><ul><li><p><strong>关注”人“，而不只是”事“</strong><br>我经常说”对事不对人“，过去一年我恰好犯了我原本以为所有程序员都会犯只有我不会犯的一个错误——只关注技术。对身边的人漠不关心，做事只追求效率而缺乏艺术。例如在问问题的时候，我总是会在谈话开始前明确我想要知道的目标，交谈过程就是尽快得到我想要得到的信息，而完全忽视了要建立一个良好沟通氛围以及关注你的谈话对象，所有的沟通只是为了在我固有的认知框架里添砖加瓦，而没有真心实意想听进去别人的不同观点，在谈话过程中也忽视了“人”这个角色的存在。举个实际一点的例子，在跟客户聊天时，如果用“How are you？”作为开头，用”have a good day, mate.”作为结尾，就会比“Hi, Mike”开头然后就吧啦吧啦说事，最后以一个“Thanks” 结尾效果好很多，时不时还能聊到一些八卦和他们开心不开心的事情，事情办得即顺利又开心。如果称前者为开放式谈话，那么后者则趋于收敛，在事情比较紧急的时候我们想要快速达到目标可以多收敛、确认谈话信息；大部分时候事情不是那么紧急，可以让谈话变得开放一些，慢一些，让谈话变得更舒服和容纳更多信息。</p></li><li><p><strong>培养全局思考的能力</strong><br>记得以前学素描的时候，我总喜欢在勾勒外形的时候就把线画得很实，在上阴影前就把物体画得很像。我自己看着很满意，但老师却要我擦掉重画，原因是我没有先描出物体结构和明暗的大关系。过去这一年我一直在各种技术的学习、各种 Session、Workshop 的准备中挣扎。我忽视了一种能力，就是描绘美好愿景，畅想美好生活的能力，而太过注重如何去计划去实施。我已经是一个好的执行者，明年我希望我还能做好一个梦想家。有一句老话这么说的，要有最朴素的生活，和最遥远的梦想。</p></li><li><p><strong>回归生活</strong><br>过去的一年几乎没怎么操心过家里的事，在公司待的时间比较多，老友相邀总推辞说忙，公司周末有活动，总想着都在成都以后有的是时间聚。但结果就是身体越来越发胖，朋友交流得越来越少。大学时描绘起以后的生活会总说——”我的未来，有房子，不用多大也不用面朝大海，落地窗，窗外有阳光；有个心爱的恋人，我们一起下厨，周末开车去逛逛公园，一年能陪爸妈几次；有工作，有4M宽带，有单反，有书看，有歌听；朋友偶尔奔过来聚一起，打打牌喝喝酒叙叙旧，如此，就很幸福了。“在快节奏的生活中，我被一股神奇的力量拖着拽着忘记了这些简单的想法，希望明年可以做得好一点，不忘初心。</p><p><img src="/images/sketch.png" alt=""></p><center><strong>素描（图片来源于网络）</strong></center></li></ul><h1 id="2018-计划"><a href="#2018-计划" class="headerlink" title="2018 计划"></a>2018 计划</h1><p>新计划开始前先来回顾一下去年的计划：</p><table><thead><tr><th style="text-align:center">计划</th><th style="text-align:center">完成情况</th></tr></thead><tbody><tr><td style="text-align:center">考取AWS专家级认证</td><td style="text-align:center">考取了助理架构师，专家级的难度可以说是超过了我的预期</td></tr><tr><td style="text-align:center">考取阿里云认证</td><td style="text-align:center">在一番调查之后觉得在云计算领域 AWS 比较有代表性了，所以放弃了这个想法</td></tr><tr><td style="text-align:center">争取一次Lead的机会</td><td style="text-align:center">达成</td></tr><tr><td style="text-align:center">参加公司招聘</td><td style="text-align:center">达成</td></tr><tr><td style="text-align:center">比较深入的研究云，PaaS服务</td><td style="text-align:center">达成</td></tr><tr><td style="text-align:center">了解性地学习学习算法，人工智能，区块链</td><td style="text-align:center">不够多，原因是没有确切产出作为推动</td></tr></tbody></table><p>从去年机会的完成状况来看，总的来说完成率还比较高。有可以改进的两个点，一是设定目标前对目标最好有清晰的认识；二是最好有明确可量化的产出作为驱动。</p><blockquote><p>重要的是“相信”本身，而不是信了什么。</p></blockquote><p>至此，明年的计划如下：</p><ul><li>健身，坚持去健身房至少打卡 60 次</li><li>提升开发技能，参与一个 1000 star 以上的开源项目，成为 committer </li><li>继续提升英文能力，拿到云计算专家级认证</li><li>学习金融和管理学方面的知识，看书 10 本，产出博客 3 篇</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2017-commit-github-yidong.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;2017年我的 github commit&lt;/strong&gt;&lt;/center&gt;



&lt;p&gt;伴随着支付宝红包羊毛党铺天盖
      
    
    </summary>
    
      <category term="学习总结" scheme="https://www.duyidong.com/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="大事记" scheme="https://www.duyidong.com/tags/%E5%A4%A7%E4%BA%8B%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>老马博客的里的图片</title>
    <link href="https://www.duyidong.com/2017/11/05/martinflower-and-his-photograph/"/>
    <id>https://www.duyidong.com/2017/11/05/martinflower-and-his-photograph/</id>
    <published>2017-11-05T07:23:28.000Z</published>
    <updated>2017-11-05T07:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作和学习的需求我订阅了<a href="https://martinfowler.com" target="_blank" rel="noopener">老马的博客</a>，今天突然收到一则更新。</p><p>是这样的一张图片:</p><p><img src="https://martinfowler.com/photos/110.jpg" alt=""></p><p>原来老马还有在博客里放图片的习惯。由于 URL 是序列的，我往前翻了几张：</p><p><img src="https://martinfowler.com/photos/109.jpg" alt=""></p><p><img src="https://martinfowler.com/photos/108.jpg" alt=""></p><p><img src="https://martinfowler.com/photos/107.jpg" alt=""></p><p>都很美，透露着淡淡的温情。猜想应该是博客主人出去玩时随手拍摄后筛选的比较好看的图片，没有 PS 痕迹，没有故意加到很高的饱和度，看起来很日常，引发了我探究这个老外业余生活的兴趣，于是我决定下载他的所有图片。</p><p>一行 Shell 命令:</p><pre><code>for i in {1..110}; do curl -O https://martinfowler.com/photos/$i.jpg &amp;; done</code></pre><p>两分钟就把一百多张图片下到了本地。脑海里不觉浮现出了刚开始做爬虫的时候把一个人所有的社交账号发布的言论装到一个数据库里的场景。</p><p>一个人的网络画像，你的邮箱，你的社区圈子，你在网上说过的话，你买过东西，你注册过的网站，甚至于你习惯使用的密码。这些信息一旦进入网络世界就不可能被擦除，如果将来 85 后 90 后登上国家领导人的位置，这些信息会怎样，我们又将如何来看待我们的过去？</p><blockquote><p>最后给一个老马图片收藏的入口：</p><p><a href="https://martinfowler.com/photos/" target="_blank" rel="noopener">https://martinfowler.com/photos/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于工作和学习的需求我订阅了&lt;a href=&quot;https://martinfowler.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;老马的博客&lt;/a&gt;，今天突然收到一则更新。&lt;/p&gt;
&lt;p&gt;是这样的一张图片:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h
      
    
    </summary>
    
      <category term="ThoughtWorks" scheme="https://www.duyidong.com/categories/ThoughtWorks/"/>
    
    
      <category term="爬虫" scheme="https://www.duyidong.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="其他" scheme="https://www.duyidong.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linode 上搭建加强版 Shadowsocks</title>
    <link href="https://www.duyidong.com/2017/11/03/how-to-setup-ss-on-linode/"/>
    <id>https://www.duyidong.com/2017/11/03/how-to-setup-ss-on-linode/</id>
    <published>2017-11-03T02:04:05.000Z</published>
    <updated>2018-02-25T15:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<p> 本文介绍如何在 Linode 上搭建 Shadowsocks，并开启 TCP BBR 拥塞算法达到稳定代理的目的。</p><h1 id="为什么选用-Linode"><a href="#为什么选用-Linode" class="headerlink" title="为什么选用 Linode"></a>为什么选用 Linode</h1><ul><li><strong>便宜</strong> 一台最小的 Linode 服务器(单CPU/1G内存/20G硬盘/1TB流量) 只需 5$ 一月，1TB 的流量只要不被攻击基本可以放心使用而不用操心流量超的问题。</li><li><strong>方便</strong> 相比于 AWS, Linode 的服务器资源申请和维护很简单，不需要你具备太多的平台知识，从这个角度来说定制化的反面就是易用性。付费也很简单，一台机器就是一台机器的钱，没有很多隐藏收费的地方。除此之外，机器重启公网 IP 也不会变，不需要像 AWS 一样还有绑定 EIP。你可能会担心这台服务器 IP 被封，Linode 有服务器 clone 功能可以很快克隆一台一模一样的服务器（with different public ip）。</li><li><strong>速度</strong> 亲测按照本文配置的 ss 外网下载速度可达 4MB/s，Youtube 1080p 可以说是无压力了。</li></ul><h1 id="注册-申请服务器"><a href="#注册-申请服务器" class="headerlink" title="注册/申请服务器"></a>注册/申请服务器</h1><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>申请注册，邀请码：<a href="https://www.linode.com/?r=1edbed5f98d2e15d9866e174f7d6653dbe63a0bf" target="_blank" rel="noopener">https://www.linode.com/?r=1edbed5f98d2e15d9866e174f7d6653dbe63a0bf</a></p><p>你需要准备一张支持美元的信用卡，并在注册时预先扣费 5$，接下来注册邮箱会收到一封确认邮件，确认后还有等一段时间的人工 Review, 大概半小时后账号就可用了。</p><h2 id="申请服务器"><a href="#申请服务器" class="headerlink" title="申请服务器"></a>申请服务器</h2><ul><li><strong>Add a Linode</strong> 创建服务器</li><li><strong>Select an instance type</strong> 因为这里只做流量转发，所以选最小的类型:1024</li><li><strong>Location</strong> 服务器位置选新加坡或日本（注意服务器位置并不等于 IP 地区）</li><li>点击 <strong>Add This Linode</strong></li></ul><p><img src="/images/linode_create_instance.jpg" alt=""></p><h2 id="配置操作系统镜像"><a href="#配置操作系统镜像" class="headerlink" title="配置操作系统镜像"></a>配置操作系统镜像</h2><ul><li>回到 Linodes 界面，点选 <strong>Deploy Images</strong></li><li>选择交换分区大小保持默认，应用操作系统镜像 <strong>Ubuntu 17.04</strong>，输入密码（服务器被创建）</li><li>Boot 服务器</li></ul><p>接下来可以再 Linodes 界面看到服务器的公网 IP，可以通过 ssh 登录服务器了。</p><pre><code>ssh root@&lt;public-ip&gt;</code></pre><h2 id="禁用密码登录（可选）"><a href="#禁用密码登录（可选）" class="headerlink" title="禁用密码登录（可选）"></a>禁用密码登录（可选）</h2><p>密码可以被猜测到，所以为了安全性通常会禁用密码登录而改用秘钥对登录。</p><p>首先将本地的公钥放到 Linode 服务器上：</p><pre><code>ssh-copy-id root@&lt;public-ip&gt;</code></pre><p>然后禁用服务器上的密码登录，方法是编辑 Linode 服务器上的 <code>/etc/ssh/sshd_config</code>文件，设置<code>PasswordAuthentication no</code>，再重启 sshd <code>service sshd restart</code></p><h1 id="搭建-Shadowsocks"><a href="#搭建-Shadowsocks" class="headerlink" title="搭建 Shadowsocks"></a>搭建 Shadowsocks</h1><h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><p>登录到服务器上，依次执行以下命令：</p><pre><code>apt update -y           # apt 更新apt install python3-pip # 安装 pip3</code></pre><h2 id="安装并开启-shadowsocks"><a href="#安装并开启-shadowsocks" class="headerlink" title="安装并开启 shadowsocks"></a>安装并开启 shadowsocks</h2><pre><code>pip3 install shadowsocks              # 安装 Shadowsocksssserver -p 8388 -k PassWord -d start # 启动 Shadowsocks, 8388是代理端口，PassWord为连接口令，-d 表示后台启动，看到 Started 即表示启动成功</code></pre><h2 id="Trouble-shooting"><a href="#Trouble-shooting" class="headerlink" title="Trouble shooting"></a>Trouble shooting</h2><h3 id="apt-update-很慢"><a href="#apt-update-很慢" class="headerlink" title="apt update 很慢"></a>apt update 很慢</h3><p>如果遇到 <code>apt update</code> 特别慢或者出现 ipv6 地址无法解析，可以参照<a href="http://www.wuce.org/disable-linode-ipv6-solve-google-error/" target="_blank" rel="noopener">这篇博客</a> 禁用 IPV6。</p><p>再不行就把 <code>/etc/apt/sources.list</code> 里的<code>http://security.ubuntu.com/ubuntu</code>源（最后三行）给注释掉</p><h1 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h1><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><ul><li>Mac客户端： <a href="https://s3.amazonaws.com/duyidong-archive/software/GoAgentX.zip" target="_blank" rel="noopener"><strong>goAgentX</strong></a> ，解压后放到 <code>Application</code> 目录里，启动。</li><li>Windows: <a href="https://github.com/shadowsocks/shadowsocks-windows/releases/download/4.0.6/Shadowsocks-4.0.6.zip" target="_blank" rel="noopener"><strong>Shadowsocks-4.0.6.zip</strong></a>, 解压后运行。</li></ul><p>配置：</p><p><img src="http://7q5cfr.com1.z0.glb.clouddn.com/kxsw3.png" alt=""></p><p>Windows 和 Mac 的客户端的配置是一样的，原理是把本机从代理端口出去的流量全部转发到 Shadowsocks 服务器，配置五个参数：</p><ul><li>本地端口：本地代理端口</li><li>服务器地址：Linode 服务器公网 IP</li><li>端口：启动 Shadowsocks server 时的端口</li><li>密码：启动 Shadowsocks server 时的密码</li><li>加密方式：默认为 <code>aes-256-cfb</code></li></ul><p>启动，看到 <code>server listening at port xxx…</code> 就表示启动成功了。</p><p>goAgentX 有两种可选项目，一种是全局代理（Global Proxy Model），一种是局部代理（Stand alone Model）。全局代理是将服务器出去的流量全部转发到代理服务器，局部代理是需要将本机流量先转发到代理端口才能启用代理。一般建议配置局部代理，这样操控性更强。</p><h2 id="Chrome-配置"><a href="#Chrome-配置" class="headerlink" title="Chrome 配置"></a>Chrome 配置</h2><p>使用插件<a href="https://chrome.google.com/webstore/search/SwitchyOmega" target="_blank" rel="noopener"><strong>SwitchyOmega</strong></a>，</p><ul><li>添加默认代理： SOCKS5/localhost/&lt;代理端口&gt;</li><li>配置转发规则（如图所示），<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> 是一个自动更新的 GFW 白名单，文本里用<code>非</code>语句表示白名单里的站点可不通过代理访问，这样就避免了代理访问国内网站速度变慢的问题。</li></ul><p><img src="/images/SwitchOmega_configure.png" alt=""></p><p>使用方法，在插件的下拉菜单中选择<code>auto switch</code>，访问 Google，测试通过。</p><h2 id="Shell-配置"><a href="#Shell-配置" class="headerlink" title="Shell 配置"></a>Shell 配置</h2><p>使用环境变量可以将 Shell 的所有流量转发到代理端口，需要始终生效可以将以下命令加入 <code>.xshrc</code>:</p><pre><code>export ALL_PROXY=socks5://127.0.0.1:&lt;代理端口&gt;</code></pre><p><code>curl -I www.google.com</code> 测试通过。但是这种方式需要程序支持 proxy 才行，要想让所有流量都走代理，推荐一款<strong>命令行代理配置神器：<a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">proxychains</a></strong>，只要在命令行前跟上这个命令，它会劫持本机出去的所有流量转发到 proxy 服务器，不管发送请求的程序支不支持 proxy。安装方式（以 Mac 为例）：</p><ul><li><p>开启 Root</p><p>OS X 10.11 后 Root 就是阉割版，最常遇到的问题就是<code>/usr/bin</code>目录下的文件没有更改权限，要获得真正的 Root 权限需要重启 Mac，在启动时按住 <code>⌘R</code>，在左上角菜单栏找到<strong>终端</strong>，打开，并执行<code>csrutil disable</code>，返回 Success…，再 <code>Reboot</code>，再打开命令行执行<code>sudo</code>就有了真正的 Root。</p></li><li><p>接下来安装 proxychains：</p><pre><code class="bash">git clone https://github.com/rofl0r/proxychains-ng.git ./configure --prefix=/usr --sysconfdir=/etcmakesudo make installsudo make install-config</code></pre><p>最后一步会看到生成一个 proxychains 的配置文件<code>/etc/proxychains.conf</code>，编辑它，将最后一行替换为<code>socks5  127.0.0.1 &lt;代理端口&gt;</code>，保存退出。</p></li><li><p>使用的时候在命令行前加上 <code>proxychains4</code>，形如：<code>proxychains4 curl -I https://www.google.com</code>，则流量都将会被转发到 proxy 服务器上。值得注意的是，这个工具<strong>只支持 TCP 协议，而 UDP/ICMP 不支持</strong>，常用场景也就是 <code>Ping</code> 是不能用的。</p></li></ul><h1 id="开启-TCP-BBR-增强版"><a href="#开启-TCP-BBR-增强版" class="headerlink" title="开启 TCP BBR 增强版"></a>开启 TCP BBR 增强版</h1><p>这部分内容来自<a href="https://moeclub.org/2017/06/06/249/" target="_blank" rel="noopener">Debian/Ubuntu 开启 TCP BBR 拥塞算法</a>，<a href="https://moeclub.org/2017/06/24/278/" target="_blank" rel="noopener">Debian/Ubuntu TCP BBR 改进版/增强版</a>，BBR 算法介绍可以参考<a href="https://www.zhihu.com/question/53559433" target="_blank" rel="noopener">知乎：Linux Kernel 4.9 中的 BBR 算法与之前的 TCP 拥塞控制相比有什么优势？</a>，太长不读版就是通过重复发包来减少流量转发过程中的丢包现象从而使代理服务更加稳定。这个功能需要 Linux 内核支持，具体操作如下：</p><h2 id="修改-Linode-服务器的-Boot-Kernel"><a href="#修改-Linode-服务器的-Boot-Kernel" class="headerlink" title="修改 Linode 服务器的 Boot Kernel"></a>修改 Linode 服务器的 Boot Kernel</h2><p>将 Linode 服务器管理界面中 <strong>Boot Settings</strong> 部分的 <strong>Kernel</strong>设置为 <code>GRUB2</code> </p><p><img src="/images/Linode_kernal_change.png" alt=""></p><h2 id="开启-TCP-BBR"><a href="#开启-TCP-BBR" class="headerlink" title="开启 TCP BBR"></a>开启 TCP BBR</h2><p>在 Linode 服务器上运行：</p><pre><code>wget --no-check-certificate -qO &#39;BBR.sh&#39; &#39;https://moeclub.org/attachment/LinuxShell/BBR.sh&#39; &amp;&amp; chmod a+x BBR.sh &amp;&amp; bash BBR.sh -f  v4.11.9</code></pre><p>期间服务器会重启一次，如果你没有给 ss 配置自动重启则需要手动起一下。</p><h2 id="增强-TCP-BBR-性能"><a href="#增强-TCP-BBR-性能" class="headerlink" title="增强 TCP BBR 性能"></a>增强 TCP BBR 性能</h2><p>在 Linode 服务器上运行：</p><pre><code>wget --no-check-certificate -qO &#39;BBR_POWERED.sh&#39; &#39;https://moeclub.org/attachment/LinuxShell/BBR_POWERED.sh&#39; &amp;&amp; chmod a+x BBR_POWERED.sh &amp;&amp; bash BBR_POWERED.sh -f v4.11.9</code></pre><p>提示 Success 则表示安装成功，Trouble Shooting 可以参考<a href="https://moeclub.org/2017/06/24/278/" target="_blank" rel="noopener">这篇文章</a>，以及<a href="http://www.wuce.org/disable-linode-ipv6-solve-google-error/" target="_blank" rel="noopener">禁用Linode ipv6解决Google提示流量异常</a>。</p><blockquote><p>如果你完成了上面所有操作，那么恭喜你，可以享受畅通无阻的翻墙体验了。</p></blockquote><p>在完成以上操作后，如果你还想进一步提升代理体验，请移步本系列第二篇博文：<a href="/2018/02/25/kcptun-shadowsocks/">使用 Kcptun 加速 Shadowsocks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 本文介绍如何在 Linode 上搭建 Shadowsocks，并开启 TCP BBR 拥塞算法达到稳定代理的目的。&lt;/p&gt;
&lt;h1 id=&quot;为什么选用-Linode&quot;&gt;&lt;a href=&quot;#为什么选用-Linode&quot; class=&quot;headerlink&quot; title=&quot;为什
      
    
    </summary>
    
      <category term="工具" scheme="https://www.duyidong.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="云服务" scheme="https://www.duyidong.com/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="代理" scheme="https://www.duyidong.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>分支模型与主干开发</title>
    <link href="https://www.duyidong.com/2017/10/29/trunk-base-development/"/>
    <id>https://www.duyidong.com/2017/10/29/trunk-base-development/</id>
    <published>2017-10-29T07:47:20.000Z</published>
    <updated>2017-10-31T08:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近我和我的所在的团队在翻译一个网站： <a href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener">https://trunkbaseddevelopment.com/</a>主干开发。本文结合笔者的开发经验，谈一谈项目中用到过的分支模型与使用场景，对主干开发做一个简单的介绍。</p><h1 id="Gitflow"><a href="#Gitflow" class="headerlink" title="Gitflow"></a>Gitflow</h1><p>Gitflow 最早应该是出现在一篇名叫<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a>的文章中，阮一峰的<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">Git 工作流程</a>做了更便于理解的阐述。正如问中提到，Gitflow 偏向控制管理，比较多地使用分支，试用 GitFlow 的项目基本上工作流会是这个样子:</p><p><img src="/images/gitflow_branches.png" alt=""></p><center>图片出自:<a href="https://yaowenjie.github.io/devops/thinking-in-two-kinds-of-ci-cd-strategies-and-git-branch-models" target="_blank" rel="noopener">关于两种CI/CD策略以及git分支模型的思考</a></center><p>Master 分支用于发布，Develop 分支用于存放待发布（不稳定）的版本。在迭代计划里，Epic 会被先划分为一个个 Feature，一个 Feature 表示一个完整的功能，这个feature 会被拆成一个个更小的 Story（卡），如果 Feature 小的话也可以是一个 Feature 对应一个 Story，一个 Story 从被创建出来到最终上线会经历以下过程：</p><ul><li>Dev 领卡，从 Develop 分支创建一个 Feature 分支。</li><li>在 Feature 分支进行开发并通过本地测试（单元测试和部分集成测试）。</li><li>从 Feature 分支发起一个 Pull-Request 到 Develop 分支。</li><li>相关人员进行 Code Review，并将 Feature 分支合并到 Develop 分支。</li><li>写卡 Dev 删除 Feature 分支，并将卡挪到 Test，交给 QA 测试。</li><li>QA 在 Develop 分支测试完成，把卡挪到 Ready for release。</li><li>等待 Realease Master 将该 Feature 从 Devlop 分支 Merge 到 Master。</li><li>QA 在 Master 分支进行测试。</li><li>测试通过后进行发布，并在Master 分支打上 Release Tag。</li></ul><p>可以看出流程是颇为复杂的。不过在一个团队成员流动相对较小，大家对 Gitflow 都比较熟悉的情况下，实施过程倒是没有遇到任何问题。而且可以感觉得到，这样的分支模型下的发布非常有计划性，Dev 之间的开发冲突也比较少（得益于 Feature 划分合理）。但在时间长了以后，问题还是逐一暴露出来，主要有以下几个：</p><ul><li><strong>重复测试</strong>，一个功能从开发到上线至少要经历三次内容重合度很高的测试：本地，Develop 分支合并，Master 分支合并；如果有 Fix bug，Merge 回 Master 还要多测一次，每一次都可能有意外的结果，而且 Develop 分支的测试和 Master 分支的测试内容几乎是一模一样的。</li><li><strong>Release Master 的存在</strong>，在一个目标为持续发布的敏捷团队里 Release Master 的存在是不合理的，Release Master 需要在上线前的一段时间一直盯着 Pipeline（持续交付流水线），这不但意味着一个劳动力的缺失，并且一个人要想掌握一次发布的左右更改细节和影响也是几乎不可能的，所以到后来每次上线前 Release Master 都要组织一次 Release Meeting，所有开发在一起讨论这次 Release 的 Feature，非常浪费时间。</li><li><strong>并没有做到持续交付</strong>，在 Gitflow 得分支模型下，发布是非常有计划的，一个 Feature 必须要经过以上这么多步骤才能到达生产环境，在时间上平均一个 Feature 都要等待 两周时间才能长线，这样的等待并非是需求上的“按计划发布”，而是从技术上就造成了发布瓶颈，显然难以达到持续交付的要求的。</li></ul><h1 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h1><p>相比 Gitflow，Github Flow 就要简单很多，介绍可以参考<a href="https://guides.github.com/introduction/flow/" target="_blank" rel="noopener">Github 官方文档</a>，同样在<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">这篇文章</a>中也可以看到中文版。在项目上使用 Github Flow 基本上分支会变成这个样子：</p><p><img src="/images/githubflow_branches.png" alt=""></p><p>所有 Story 直接提交到 Feature 分支，再从 Feature 分支发 Pull-Request 到主分支（Master 或 Develop），Pull-Request 是为了方便 Code Review，相比于 Gitflow，这种方式因为省去了一些分支而降低了复杂度，同时也更复合持续集成的思想，以一张故事卡为集成的最小单位，相对来说集成的周期短，反馈的速度也快，能够及早的遇到问题，从而及早的解决问题。</p><p>Github flow 的另一个好处在于，可以处理跨团队协作问题。当时的项目是一个多团队共享的基础设施代码库，大部分团队需要同样的功能，就从主库 Fork 一份代码，一旦产品团队产生定制化的需求，就可以在自己的代码库里更改，并向主库发一个 Pull-Request，如果主库的维护团队认为这是一个有通用价值的更改，则会接受合并到主库中。这种方式就既保证了分布式团队拥有代码和主库的同步，又让各团队都可以向主库贡献代码，非常适合多个独立团队工作在一个代码库的情形。</p><p><img src="https://git-scm.com/figures/18333fig0502-tn.png" alt=""></p><center>图片来源：<a href="https://ruby-china.org/topics/29263" target="_blank" rel="noopener">GIT 之我见</a></center><h1 id="Trunk-Based-Development"><a href="#Trunk-Based-Development" class="headerlink" title="Trunk Based Development"></a>Trunk Based Development</h1><p>顺着持续集成的思想，如果我们把上一种分支模型做得再极致一点，我们不要 Feature 分支，或者把 Feature 分支只留在本地；不需要使用 Pull-Request 而是直接 Push 到远程 Master 分支，我们就做到了 Trunk based Development。（关于从 GitFlow 到 TBD 的论述，TW 同事尚齐在洞见上有一篇<a href="http://insights.thoughtworkers.org/gitflow-consider-harmful/" target="_blank" rel="noopener">Gitflow有害论</a>值得一读，另外想要了解得更细致可以去到<a href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener">官网</a>（<a href="https://cn.trunkbaseddevelopment.com/" target="_blank" rel="noopener">中文版</a>），里面详细列举了各种实践和反模式。）本文主要就项目上落地过程中遇到的一些问题做个简要的说明。</p><p>使用主干开发后，我们的代码库原则上就只能有一个 Master 分支了，所有新功能的提交也都提交到 Master 分支上，没有了分支的代码隔离，测试和解决冲突都变得简单，持续集成也变得稳定了许多，问题也接踵而至，主要有以下三个：</p><ul><li>如何避免发布的时候引入未完成的 Feature </li><li>如何进行线上 Bug Fix</li><li>如何重构</li></ul><p><img src="http://paulhammant.com/images/what_is_trunk.jpg" alt=""></p><center>图片来自:<a href="https://paulhammant.com/2013/04/05/what-is-trunk-based-development/" target="_blank" rel="noopener">What is Trunk-Based Development?</a></center><h2 id="如何避免发布引入未完成-Feature"><a href="#如何避免发布引入未完成-Feature" class="headerlink" title="如何避免发布引入未完成 Feature"></a>如何避免发布引入未完成 Feature</h2><p>答案是： <a href="https://martinfowler.com/articles/feature-toggles.html" target="_blank" rel="noopener">Feature Toggle</a>。</p><p>既然代码要随时保持可发布，而我们又需要只有一份代码来支持持续集成，在代码库里加一个特性开关来随时打开和关闭新特性是最容易想到的也是最容易被质疑的解决方案。</p><p>Feature Toggle 是有成本的，不管是在加 Toggle 的时候的代码设计，还是在移除 Toggle 时的人力成本和风险，都是需要和它带来的价值进行衡量的。事实上，在我们做一个前端的大特性变更的时候，我们确实没有因为没办法 Toggle 而采用了一个独立的 Feature 分支，我们认为即使为了这个分支单独做一套 Pipeline，也比在前端的各种样式间添加移除 Toggle 来得简单。但同时，团队商议决定在每次提交前都要先将 Master 分支 Merge 到 Feature 分支，以此避免分支隔离久以后合并时的痛苦。</p><h2 id="如何进行线上-Bug-Fix"><a href="#如何进行线上-Bug-Fix" class="headerlink" title="如何进行线上 Bug Fix"></a>如何进行线上 Bug Fix</h2><p>在发布时打上 Release Tag，一旦发现这个版本有问题，如果这个时候Master分支上没有其他提交，可以直接在 Master 分支上 Hot Fix，如果 Master 分支已经有了提交就要做以下三件事：</p><ul><li>从 Release Tag 创建发布分支。</li><li>在 Master 上做 Fix Bug 提交。</li><li>将 Fix Bug 提交 Cherry Pick 到 Release 分支。</li><li>在Release 分支再做一次发布。</li></ul><p>线上 Fix 通常都比较紧急。看完这个略显繁琐 Bug Fix 流程，你可能会问为什么不在 Release 分支直接 Fix，再合并到 Master 分支？</p><p>这样做确实比较符合直觉，但事实是，如果在 Release 分支做 Fix，很可能会忘了 Merge 回 Master，试想深夜两点你做完 Bug Fix 眼看终于上线成功，这时的第一反应就是“终于可以下班了。什么，Merge 回 Master？ 明天再来吧“ 等到第二天你早已把这个事忘得一干二净。而问题要等到下一次上线才会被暴露出来，一旦发现，而这个时候上一次 Release 的人又不在，无疑增加了很多工作量。</p><h2 id="如何重构"><a href="#如何重构" class="headerlink" title="如何重构"></a>如何重构</h2><p>这里指的是比较大规模的重构，无法在一次提交完成，TBD 要求每一次提交都是一个可上线的版本，所以这同时还意味着这个重构无法再一个上线周期内完成。</p><p>这种情况，需要在代码设计中增加一个抽象层，保证在重构过程中先不动原来的代码，也不破坏既有功能，类似于蓝绿部署中的负载均衡器的作用，这样的流程就是：</p><p><img src="/images/TBD_Abstraction_layer.png" alt=""></p><ul><li>在将要被重构的代码逻辑附近引入抽象层然后提交，对所有人可见。如果有需要可以是多个提交，这些提交都不能破坏 build，然后依次 push 到共享代码库。</li></ul><ul><li>为将要被引入的代码写抽象层的第二次实现，然后提交。但在主干上由于关闭状态所以其他开发人员暂时不依赖于它。如果需要的话，这可能像上面那样需要多次提交。第一步的抽象层也可能偶然被调整，但必须遵循同样的原则：不能破坏build。</li><li>切换使用重构后的代码，然后 Push。</li><li>删除原有的旧实现（被重构代码）</li><li>删除抽象层</li></ul><p>这个流程和汽车换轮胎有那么点类似，新旧轮胎代表重构前后代码，抽象层就好比千斤顶。</p><p><img src="https://cn.trunkbaseddevelopment.com/branch-by-abstraction/cars.png" alt=""></p><center>图片来自: <a href="https://cn.trunkbaseddevelopment.com/branch-by-abstraction/" target="_blank" rel="noopener">主干开发：抽象分支</a></center><h1 id="一点感受"><a href="#一点感受" class="headerlink" title="一点感受"></a>一点感受</h1><p>TBD 还因为被 Google，亚马逊这样的公司采用而闻名，可以参照阮一峰的另篇文章：<a href="http://www.ruanyifeng.com/blog/2016/07/google-monolithic-source-repository.html" target="_blank" rel="noopener">谷歌的代码管理</a>，但并不因此意味着 TBD 就适用于所有场景。即使是是 CICD 已经被广泛接受，也不能称持续交付为软件开发的银弹。技术用的对不对，还是要看上下文。</p><p>最后附上 Truk Based Development 的中文网站（还在翻译中）：<a href="https://cn.trunkbaseddevelopment.com/" target="_blank" rel="noopener">https://cn.trunkbaseddevelopment.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近我和我的所在的团队在翻译一个网站： &lt;a href=&quot;https://trunkbaseddevelopment.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://trunkbaseddevelopment.com/&lt;/a&gt;主干开
      
    
    </summary>
    
      <category term="持续交付" scheme="https://www.duyidong.com/categories/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    
    
      <category term="git" scheme="https://www.duyidong.com/tags/git/"/>
    
      <category term="coding" scheme="https://www.duyidong.com/tags/coding/"/>
    
      <category term="持续集成" scheme="https://www.duyidong.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="主干开发" scheme="https://www.duyidong.com/tags/%E4%B8%BB%E5%B9%B2%E5%BC%80%E5%8F%91/"/>
    
      <category term="TBD" scheme="https://www.duyidong.com/tags/TBD/"/>
    
  </entry>
  
  <entry>
    <title>Openshift 多节点部署</title>
    <link href="https://www.duyidong.com/2017/09/23/openshift-cluster-in-aws/"/>
    <id>https://www.duyidong.com/2017/09/23/openshift-cluster-in-aws/</id>
    <published>2017-09-23T14:10:00.000Z</published>
    <updated>2017-09-25T12:23:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何在 AWS 中搭建一个 Openshift 集群。</p><p>主要用到的资源：<a href="https://github.com/openshift/openshift-ansible-contrib/tree/master/reference-architecture/aws-ansible" target="_blank" rel="noopener">https://github.com/openshift/openshift-ansible-contrib/tree/master/reference-architecture/aws-ansible</a></p><p>开始之前你最好对这这些知识点有一定了解：<a href="https://www.duyidong.com/2017/02/28/AWS-Services-Overview/">AWS</a> (<a href="https://www.duyidong.com/2017/03/15/AWS-EC2/">EC2</a>, ELB, <a href="https://www.duyidong.com/2017/03/06/%E6%B5%85%E8%B0%88AWS-IAM/">IAM</a>, <a href="https://www.duyidong.com/2016/08/02/AWS%E4%B9%8BCloudFormation/">CloudFormation</a>)，<a href="https://www.duyidong.com/2016/06/15/Ansible%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/">Ansible</a>，<a href="https://www.duyidong.com/2016/08/05/Bash%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%A1/">Bash</a>，同时建议先看看本博客中关于 Openshift 和 Kubernetes 的基础知识：<a href="https://www.duyidong.com/2017/06/14/kubernetes-and-openshift/">Part 1</a> <a href="https://www.duyidong.com/2017/06/15/kubernetes-infrastructure/">Part 2</a> <a href="https://www.duyidong.com/2017/06/15/openshift-quick-start/">Part 3</a></p><p>完整的 Openshift 架构：</p><p><img src="https://github.com/openshift/openshift-ansible-contrib/raw/master/reference-architecture/aws-ansible/images/arch.jpg" alt=""></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>使用 Route53 申请一个域名。这里注册为 <code>oc-tw.net</code> ，后文中出现这个 <code>oc-tw.net</code> 的部分请替换为注册域名。</li><li>选择一个至少有 3 个 AZ 的 Region。这里选择为悉尼，Region id（可在console的 URL 中获得）为：ap-southeast-2。</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="创建堡垒机"><a href="#创建堡垒机" class="headerlink" title="创建堡垒机"></a>创建堡垒机</h2><p>这个堡垒机是用于运行 Ansible 脚本及配置集群使用，并非 Openshift 集群的一部分。所以可以用手动创建的方式，可以选择在本地运行。</p><p>从 Marketplace 找一个 Centos7 的 AMI （如图所示）创建一个 EC2 instance 并绑定一个 EIP，开启 22 端口。</p><p><img src="/images/aws_marketplace_ami_centos7.png" alt=""></p><p>Instance 启动完成后，登录到堡垒机上，执行如下安装命令：（后面的全部命令行操作均在堡垒机上执行）</p><pre><code>yum -y install atomic-openshift-utils ansible openshift-ansible-playbooksrpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmyum -y install python2-boto \                 pyOpenSSL \                 git \                 python-netaddr \                 python-six \                 python2-boto3 \                 python-click \                 python-httplib2rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmyum -y install python-pip git python2-boto \                 python-netaddr python-httplib2 python-devel \                 gcc libffi-devel openssl-devel python2-boto3 \                 python-click python-six pyOpenSSL</code></pre><h2 id="获取-Ansible-脚本"><a href="#获取-Ansible-脚本" class="headerlink" title="获取 Ansible 脚本"></a>获取 Ansible 脚本</h2><pre><code>mkdir -p /usr/share/ansible/openshift-ansible# Openshift 官方配置脚本git clone https://github.com/openshift/openshift-ansible.git /usr/share/ansible/openshift-ansible# contribution 脚本git clone https://github.com/openshift/openshift-ansible.gitcd openshift-ansible-contrib/reference-architecture/aws-ansible/</code></pre><h2 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h2><pre><code>vi ~/.ssh/configHost *.oc-tw.net           # 这里需要替换申请来的注册域名     ProxyCommand               ssh ec2-user@bastion -W %h:%p        IdentityFile               /root/.ssh/yidong_ohio_openshift.pemHost bastion     Hostname                   bastion.oc-tw.net       # 替换为注册域名     user                       ec2-user                 StrictHostKeyChecking      no     ProxyCommand               none     CheckHostIP                no     ForwardAgent               yes     IdentityFile               /root/.ssh/yidong_sydney.pem  # 保存在本地的 ssh 私钥</code></pre><h2 id="AWS-秘钥对写入环境变量"><a href="#AWS-秘钥对写入环境变量" class="headerlink" title="AWS 秘钥对写入环境变量"></a>AWS 秘钥对写入环境变量</h2><p>由于堡垒机需要申请 AWS 资源并取得配置权限，所以需要配置 AWS 秘钥对，这里因为 Ansible 是从环境变量里获得 AWS 秘钥的，所以没有使用 IAM role。</p><pre><code>export AWS_ACCESS_KEY_ID=fooexport AWS_SECRET_ACCESS_KEY=bar</code></pre><h2 id="设置-Github-OAuth"><a href="#设置-Github-OAuth" class="headerlink" title="设置 Github OAuth"></a>设置 Github OAuth</h2><p>这里需要使用 github OAuth 完成单点登录设置，参照<a href="https://help.github.com/enterprise/2.10/admin/guides/user-management/using-github-oauth/" target="_blank" rel="noopener">官方文档</a>。</p><p><img src="/images/Github_OAuth_App.png" alt=""></p><p><strong>Homepage URL</strong> 格式为：<a href="https://openshift-master.oc-tw.net" target="_blank" rel="noopener">https://openshift-master.oc-tw.net</a> （一二级域名替换为注册域名）</p><p><strong>Authorization callback URL</strong> 格式为：<a href="https://openshift-master.oc-tw.net/oauth2callback/github" target="_blank" rel="noopener">https://openshift-master.oc-tw.net/oauth2callback/github</a>（一二级域名替换为注册域名）</p><p>OAuth App 添加完成后将会得到一个 <strong>Client ID</strong> 和一个 <strong>Client Secret</strong>，后面会使用到。</p><h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>在堡垒机中<code>openshift-ansible-contrib/reference-architecture/aws-ansible/</code>目录下创建并执行如下脚本：</p><pre><code>./ose-on-aws.py \--keypair=yidong_sydney \                    # 所以 EC2 Instance 用于通信的 keypair--public-hosted-zone=oc-tw.net \             # 注册域名--deployment-type=origin \                   # 在 Region 部署(会创建 VPC )--ami=ami-ccecf5af \                         # 注意*--github-client-secret=&lt;Client Secret&gt; \     # Github Client Secret--github-organization=&lt;Organization name&gt; \  # Github 中 OAuth Organization 的名字--github-client-id=&lt;Client ID&gt; \             # Github Client ID--region=ap-southeast-2 \                    # 堡垒机所在 Region，也是创建 Openshift 集群的 Region--key-path=/root/.ssh/yidong_sydney.pem \    # 堡垒机上私钥存放位置--containerized=true                         # 集群以容器的方式启动</code></pre><blockquote><p>*这里有一个需要特别注意的地方，就是 AMI 必须使用 RHEL 的 AMI，在 AWS 中 RHEL 会比 CentOS 大约贵 30%，但是使用 CentOS 会比 REHL 缺很多包，安装起来非常麻烦，所以建议直接使用 RHEL，AMI ID 可以在直接在 AWS EC2 lunch instance 的界面中找到。</p></blockquote><p>还有很多可配置项，保持默认值即可。</p><h2 id="创建集群基础设施"><a href="#创建集群基础设施" class="headerlink" title="创建集群基础设施"></a>创建集群基础设施</h2><p>运行脚本，大致逻辑是：</p><p>使用 Cloudformation 创建基础设施资源 -&gt; 使用 Ansible连接 EC2 instance 并配置集群 -&gt; 开启监控和日志搜集。</p><p>Cloudformation 里的基础设施大致包含：EC2, EIP, SG, ELB,  IAM(User, Role, Policy, AccessKey), VPC(RouteTable, Subnet, Route, InternetGateway, RouteTable), NatGateway。</p><p><img src="/images/Openshift_Instances.png" alt=""></p><blockquote><p>注意：这套脚本所启动的集群至少需要 9 个 EC2 instance，（如图所示）从 t2.micro 到 m4.xlarge，在Cloudformation 创建开始后，如果你的账户没有在免费试用期每小时大概会划费 2-3$，具体参见<a href="https://aws.amazon.com/ec2/pricing/on-demand/" target="_blank" rel="noopener">官方文档</a>，注意选择<code>RHEL</code>和<code>你所在的Region</code>，价格会有差异。</p></blockquote><h2 id="Trouble-Shooting"><a href="#Trouble-Shooting" class="headerlink" title="Trouble Shooting"></a>Trouble Shooting</h2><p>Ansible 脚本的运行时间大概在一个小时，有 4000+ 个 Tasks（有的是重复执行），这里列举一些常见错误并给出解决思路。</p><h3 id="Anisble-连接不上目标机"><a href="#Anisble-连接不上目标机" class="headerlink" title="Anisble 连接不上目标机"></a>Anisble 连接不上目标机</h3><p>形如下图，如果错误中包含连接错误或是 SSH 问题，</p><p><img src="/images/Ansibe_Trouble_SSH.png" alt=""></p><p>Repo 里的 Ansible 是通过 SSH 连接配置目标机的，这种情况以下三种原因基本可以覆盖：</p><ol><li>SSH Config 没写对</li><li>Key Pair 有问题</li><li>服务器指纹有问题</li></ol><p>排查思路：直接尝试从堡垒机 SSH 到目标机（<code>ssh &lt;instance name&gt;</code>这里因为配置了域名解析所以可以直接用 instance name ssh），再根据错误信息排查（可以跟上参数 -vvvv 打印详细日志），如果 SSH 能成功，Ansible 执行也就没有问题。</p><h3 id="找不到-Docker"><a href="#找不到-Docker" class="headerlink" title="找不到 Docker"></a>找不到 Docker</h3><p>形如：</p><p><img src="/images/Ansible_Trouble_Docker_NotFound.png" alt=""></p><p>是由于 Docker registry 没有配置正确，需要手动到机器上执行 <code>yum-config-manager --enable rhui-REGION-rhel-server-extras</code>，写个 for 循环自动执行：</p><pre><code>all_hosts=&quot;master01 master02 master03 app-node01 app-node02 infra-node01 infra-node02 infra-node03&quot;for h in $all_hosts; do ssh ec2-user@ose-$h.oc-tw.net &#39;sudo yum-config-manager --enable rhui-REGION-rhel-server-extras -y&#39;; done</code></pre><h3 id="缺少依赖"><a href="#缺少依赖" class="headerlink" title="缺少依赖"></a>缺少依赖</h3><p>形如：</p><p><img src="/images/Ansible_Trouble_Dependence.png" alt=""></p><p>解决思路比较简单，缺什么装什么，比如缺少<code>httpd-tools</code>:</p><pre><code>sudo yum install -y httpd-tools</code></pre><p>不过有的包可能会麻烦点，需要在网上找一下，比如<code>python-passlib</code>:</p><pre><code>rpm -Uvh ftp://rpmfind.net/linux/centos/7.4.1708/extras/x86_64/Packages/python-passlib-1.6.5-2.el7.noarch.rpm</code></pre><h1 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h1><p><img src="/images/Openshift_Install_Success.png" alt=""></p><p>经过一段时间的运行，脚本跑完的时候也就说明 Openshift 安装成功了，这个时候你可以通过<a href="https://openshift-master.oc-tw.net/console/" target="_blank" rel="noopener">https://openshift-master.oc-tw.net/console/</a> 这个连接访问它的 Console 界面，直接使用 GitHub账号登录。</p><p>同时一个外部可访问的 Registry 也被创建出来（如图） <a href="https://registry-console-default.apps.oc-tw.net/" target="_blank" rel="noopener">https://registry-console-default.apps.oc-tw.net/</a></p><p><img src="/images/Openshift_Registry_Console.png" alt=""></p><p>查看 Node，登录到其中一台 master node 上执行 <code>oc get nodes -o wide</code></p><p><img src="/images/Openshift_Cluster_Nodes.png" alt=""></p><h1 id="命令行登录"><a href="#命令行登录" class="headerlink" title="命令行登录"></a>命令行登录</h1><p>使用 Token 登录，可以在 <a href="https://openshift-master.oc-tw.net/console/command-line" target="_blank" rel="noopener">https://openshift-master.oc-tw.net/console/command-line</a> 获取登录 Token</p><pre><code>oc login https://openshift-master.oc-tw.net --token=bcD3sprC9hjOgopov9VfbHEaBbPK03WQt23MXm-KtGw# 尝试创建新 appoc new-app centos/ruby-22-centos7~https://github.com/openshift/ruby-ex.git</code></pre><h1 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h1><p>添加 Node：</p><pre><code>./add-node.py --region=us-east-2 --keypair=yidong_sydney --public-hosted-zone=oc-tw.net --deployment-type=origin --ami=ami-ccecf5af \--use-cloudformation-facts --subnet-id=subnet-1139825c \--node-type=app --shortname=ose-app-node03 --existing-stack=openshift-infra</code></pre><p>销毁 Openshift 集群：（也可以直接删除 Cloudformation Stack）</p><pre><code>ansible-playbook -i inventory/aws/hosts \    -e &#39;region=us-east-2 stack_name=openshift-infra ci=true&#39; \    -e &#39;extra_app_nodes=openshift-infra-ose-app-node03&#39; \    playbooks/teardown.yaml</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍如何在 AWS 中搭建一个 Openshift 集群。&lt;/p&gt;
&lt;p&gt;主要用到的资源：&lt;a href=&quot;https://github.com/openshift/openshift-ansible-contrib/tree/master/reference-arch
      
    
    </summary>
    
      <category term="Cloud &amp; PaaS" scheme="https://www.duyidong.com/categories/Cloud-PaaS/"/>
    
    
      <category term="AWS" scheme="https://www.duyidong.com/tags/AWS/"/>
    
      <category term="DevOps" scheme="https://www.duyidong.com/tags/DevOps/"/>
    
      <category term="PaaS" scheme="https://www.duyidong.com/tags/PaaS/"/>
    
      <category term="Openshift" scheme="https://www.duyidong.com/tags/Openshift/"/>
    
      <category term="Kubernetes" scheme="https://www.duyidong.com/tags/Kubernetes/"/>
    
      <category term="平台即服务" scheme="https://www.duyidong.com/tags/%E5%B9%B3%E5%8F%B0%E5%8D%B3%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>ThoughtWorks 技术面试</title>
    <link href="https://www.duyidong.com/2017/09/19/tw-tech-interview/"/>
    <id>https://www.duyidong.com/2017/09/19/tw-tech-interview/</id>
    <published>2017-09-19T06:12:33.000Z</published>
    <updated>2017-09-19T06:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一次参加公司校招面试，还是比较有感触的。在此之前我理解的校招面试大多得考运气，因为大家普遍认为校招进来的学生什么都不会，需要从零培养，所以我也一直认为 TW 的校招无非就是挑选一些看起来比较聪明的孩子，技术方面没有过多要求。今日一见，发觉相去甚远，公司凭借稍长的面试周期，从技术，性格，成长多维度的考察，可谓是360度无死角地最大限度保证了应届生质量。</p><p>这次校招主要分以下几个阶段：HR电话面试 -&gt; Homework -&gt; 技术面试 -&gt; HR 终面，笔者作为 Developer 参加了看作业和技术面试两个环节，从和资深面试官结对面试到听 HR 们对候选人的评价分析，不但学习到如何辨识优秀应届生，对自我审查也是大有裨益。</p><p>基本上应届生中有以下几种能力是比较被看重的：</p><h1 id="扎实的基本工"><a href="#扎实的基本工" class="headerlink" title="扎实的基本工"></a>扎实的基本工</h1><p>考察基本功第一个点就是家庭作业，Homework 实现起来其实都不难，考察点主要在代码质量，处理逻辑，和工程实践上，这些考察点均要建立在平时有足够的编码实践，有扎实的基础知识的前提下。基础稍弱的候选人在作业上表现往往表现出读题不仔细，功能实现不完整，未按题目要求作答，例如题目中明确要求要面向对象，而交上来的作业却只有一个类，这样的代码显然不能通过作业审查。扎实的基础还会表现在现场面试时针对作业的交流上，平时在学校写代码可能很少有用语言去解释代码的机会，面试的时候对实现细节的描述就很容易暴露候选人对语言特性和实现机制是否了解。</p><p>扎实的基本功并非一朝一夕可以练就，需要从平时的学习中来，还需要候选人有强烈的好奇心不断地钻研，实现功能的同时不但要知其然还要<strong>知其所以然</strong>，最好还能列出几种实现方式，并说清楚他们的优势劣势。这一点我想对所有的程序员都适用。</p><h1 id="熟练的编程技能"><a href="#熟练的编程技能" class="headerlink" title="熟练的编程技能"></a>熟练的编程技能</h1><p>说起 ThoughtWorks 的现场面试，最容易让人脸红心跳的可能就是结对编程环节，这个环节除了处理好情绪上的问题之外最重要的还是平时的积累，一句话就是要<strong>多写</strong>。这一点差距是很明显的，不太写代码的候选人拿到题目就会咬指甲、紧张、沉思很久，写起代码来磕磕绊绊，IDE 频繁报错还不知道错从何来。而编程技能熟练的候选人除了能做到流畅书写代码之外甚至还能够边写边解释，这一步是在做什么，为什么这样做，对面试官提出的提问还能做出深入的解释，快速响应面试官提出的修改意见，这都离不开平时的练习。</p><p>这一点主要还是要靠平时跟着老师做项目，研究生会比较占优势。或者凭借自己的兴趣写点小工具解决自己生活中的问题，要是有参与过开源项目就更出彩了。</p><h1 id="实事求是的简历"><a href="#实事求是的简历" class="headerlink" title="实事求是的简历"></a>实事求是的简历</h1><p>这次面试比较多的遇到了这种情况：从简历上看，这位候选人很优秀，学霸，项目经验丰富，各种技术齐全，落坐也是自信满满，可一到提问环节，越深入问下去越是伤痕累累，一问到细节就答不上来或者想蒙混过关。这其实反应出后选人在平时编码过程中缺乏思考，没有理解透彻，尤其对习惯于“项目驱动学习”或是“老师驱动学习”的同学表现明显，好的程序员不但应有<strong>主动学习</strong>的习惯，还应掌握一定的<strong>学习方法</strong>，具体可以参考我司同事写的这篇<a href="http://insights.thoughtworks.cn/getting-started-guide-to-self-learner/" target="_blank" rel="noopener"> 写给自学者的入门指南</a>。另外对于蒙混过关这种行为着实不可取，参与面试的考官平均工作年限也有七八年，一些没吃透的知识点其实很容易就被看出来了。</p><p>这一点还是要求候选人要对自己简历上写的东西负责，“精通”，“熟悉”这类词要慎用，尤其不要想显得什么都会，还是要突出重点，再有就是选择投简历的时候看着点方向，尽可能去吻合自己熟悉和感兴趣的领域。</p><h1 id="不要把面试太当回事，秀出你自己"><a href="#不要把面试太当回事，秀出你自己" class="headerlink" title="不要把面试太当回事，秀出你自己"></a>不要把面试太当回事，秀出你自己</h1><p>一些候选人在面试的时候会比较紧张，尤其到根据简历提问的环节，会显得畏首畏尾，这样的候选人除了可能面试经验不足，我推测在他们心里一定还把面试当成了一场考试，时时想着“千万不要考我不懂的地方”，“千万不要问我去年那个项目因为我没做点啥”，可是越是畏惧越是漏出破绽（根据<a href="https://baike.baidu.com/item/%E5%A2%A8%E8%8F%B2%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">墨菲定律</a>，如果你担心某种情况发生，那么它就更有可能发生）。其实可以换种思路，面试是让你秀出自己，说你擅长的，聊你想聊的。在众多后续人让你脱颖而出的一定是你的自信和你的闪光点，考官并不会像试卷一样为难你（其实考试也不是，只是人往往更容易记住那些让你绞尽脑汁的体验，就跟老师同学会上总会对班上的差生印象深刻一个道理），相反考官其实很想看到你擅长的地方地方是什么，他们会小心翼翼地提问，哪个项目是你映像最深刻的，深入细节前先问问这个技术是不是你熟悉的，如果不是那我们就换一个也没关系，目的就是要看到候选人在自己擅长的领域究竟有多擅长，对自己“喜欢”的技术究竟有投入多少去学习。这一点可能是 TW 和别的公司不太一样的地方，产品公司技术面试一般会偏重公司用到的技术，因为大部分时候他们在发布招聘启事的时候已经想好怎么用这个人了，而 TW 因为项目类型繁多各式技术都有涉及，所以会更关注候选人自己的兴趣和技术方向，候选人应该充分利用这一点，引导考官来到自己擅长的领域，我们会非常乐意看到出彩的你。</p><h1 id="面试之前问问你自己：你真的喜欢编程吗？"><a href="#面试之前问问你自己：你真的喜欢编程吗？" class="headerlink" title="面试之前问问你自己：你真的喜欢编程吗？"></a>面试之前问问你自己：你真的喜欢编程吗？</h1><p>很多考生在来之前会做很多功课，了解公司面试流程和喜好偏向，甚至为心仪的公司准备定制好的简历，这是聪明的做法。但我认为有一类人在面 TW 前可以说几乎不需要准备，那就是他真正热爱编程。如果你热爱编程，你一定会投入时间和经历去学习，如果你经常写代码，你一定会遇到很多问题并自己动手解决，在此过程中自然会积累扎实的编程技能，如果你有丰富的编程经验，必然会有一份拿得出手且不需要过度美化的简历。如果你以上都满足了，面试的时候不用太紧张，聊你想聊的，秀你想秀的，你会和面试官成为朋友并获得他的强烈推荐的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次参加公司校招面试，还是比较有感触的。在此之前我理解的校招面试大多得考运气，因为大家普遍认为校招进来的学生什么都不会，需要从零培养，所以我也一直认为 TW 的校招无非就是挑选一些看起来比较聪明的孩子，技术方面没有过多要求。今日一见，发觉相去甚远，公司凭借稍长的面试周期，
      
    
    </summary>
    
      <category term="ThoughtWorks" scheme="https://www.duyidong.com/categories/ThoughtWorks/"/>
    
    
      <category term="ThoughtWorks" scheme="https://www.duyidong.com/tags/ThoughtWorks/"/>
    
      <category term="面试" scheme="https://www.duyidong.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="职场" scheme="https://www.duyidong.com/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新特性</title>
    <link href="https://www.duyidong.com/2017/08/30/what-new-in-java8/"/>
    <id>https://www.duyidong.com/2017/08/30/what-new-in-java8/</id>
    <published>2017-08-30T02:42:34.000Z</published>
    <updated>2018-02-22T13:12:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 从 1995年正式发布第一个版本至今已走过 21 个年头，从一开始受人怀疑的慢语言发展为如今通用的健壮语言。笔者 11 年开始接触 Java1.6 到后来转投 Python，再转向云架构，而今因项目需求再次拾起 Java 已经过了两次版本更新，借项目上的机会，将 Java8 的新特性做一个梳理。</p><p><a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">官方文档</a>； <a href="https://s3.amazonaws.com/duyidong-archive/pdf/What_new_in_java8_yidong.key" target="_blank" rel="noopener">PPT</a></p><h1 id="（一）Programming-Language"><a href="#（一）Programming-Language" class="headerlink" title="（一）Programming Language"></a>（一）Programming Language</h1><h2 id="Lambda-表达式-Lambda-Expression"><a href="#Lambda-表达式-Lambda-Expression" class="headerlink" title="Lambda 表达式 (Lambda Expression )"></a>Lambda 表达式 (Lambda Expression )</h2><p>Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>形如: <code>input -&gt; body</code></p><h2 id="在代码中"><a href="#在代码中" class="headerlink" title="在代码中:"></a>在代码中:</h2><pre><code>(arg1, arg2...) -&gt; { body }(type1 arg1, type2 arg2...) -&gt; { body }</code></pre><p>示例如下：</p><pre><code>() -&gt; 42a -&gt; return a*a(int a, int b) -&gt; {  return a + b; }() -&gt; System.out.println(&quot;Hello World&quot;);(String s) -&gt; { System.out.println(s); }</code></pre><p><strong>注意:</strong></p><p>lambda 表达式只能引用 final 或 final 局部变量，这就是说不能在 lambda 内部修改定义在域外的变量，否则会编译错误。</p><h2 id="方法引用-Method-References"><a href="#方法引用-Method-References" class="headerlink" title="方法引用 (Method References)"></a>方法引用 (Method References)</h2><p>适用场景：当一个Lambda表达式调用了一个已存在的方法</p><ul><li>构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new</li><li>静态方法引用：它的语法是Class::static_method</li><li>特定类的任意对象的方法引用：它的语法是Class::method</li><li>特定对象的方法引用：它的语法是instance::method</li></ul><p>示例如下:</p><pre><code>// 使用Lambda表达式(a, b) -&gt; {return a * b};// 使用Lambda表达式，调用已存在的方法(a, b) -&gt; Calculator.calculate(a, b);// 使用方法引用Calculator::calculate;</code></pre><p>换句话说，</p><blockquote><p><em>Instead of using</em><br><strong>AN ANONYMOUS CLASS</strong><br><em>you can use</em><br><strong>A LAMBDA EXPRESSION</strong><br><em>And if this just calls one method, you can use</em><br><strong>A METHOD REFERENCE</strong></p></blockquote><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener">一个完整的例子</a> (<a href="https://my.oschina.net/luoyezhuifeng/blog/801343" target="_blank" rel="noopener">中文翻译</a>)</p><p><strong>注意：</strong></p><p>当需要往引用的方法传其它参数的时候不适用，如下示例：</p><pre><code>IsReferable demo = () -&gt; ReferenceDemo.commonMethod(&quot;Argument in method.&quot;);</code></pre><h2 id="函数式接口（Functional-Interface）"><a href="#函数式接口（Functional-Interface）" class="headerlink" title="函数式接口（Functional Interface）"></a>函数式接口（Functional Interface）</h2><p>任何接口，如果只包含一个抽象方法（这种类型的接口也称为SAM接口，即Single Abstract Method interfaces），那么它就是一个函数式接口。为了让编译器帮助我们确保一个接口满足函数式接口的要求，Java8 提供了<code>@FunctionalInterface</code>注解，Java 不会强制要求你使用<code>@FunctionalInterface</code>注解来标记你的接口是函数式接口， 然而，作为API作者， 你可能倾向使用<code>@FunctionalInterface</code>指明特定的接口为函数式接口， 这只是一个设计上的考虑， 可以让用户很明显的知道一个接口是函数式接口。</p><p>函数式接口的一个非常重要的用途就是对Lambda提供支持，看下面的例子：</p><pre><code>public class Book {    public String name;    public String author;    public double price;}public class BookStore {    private List&lt;Book&gt; books = new ArrayList&lt;&gt;();}</code></pre><p>现在我希望BookStore能够筛选出BookStore中符合某种条件书籍，筛选条件可能多种多样，比如，所有Martin Fowler的著作，或者价格大于某个金额的所有书籍，于是，我们新增了BookFilter接口，并且为BookStore添加了list方法：</p><pre><code>public interface BookFilter {    boolean test(Book book);}public class BookStore {    private List&lt;Book&gt; books = new ArrayList&lt;&gt;();    public List&lt;Book&gt; list(BookFilter filter) {        List&lt;Book&gt; result = new ArrayList&lt;&gt;();        books.forEach(book -&gt; {            if (filter.test(book)) {                result.add(book);            }        });        return result;    }}</code></pre><p>现在，我们就可以在调用list方法时使用Lambda表达式了：</p><pre><code>// 筛选出所有价格大于15.0的书籍bookStore.list(book -&gt; book.price &gt; 15.0)</code></pre><p>因为BookFilter是一个函数式接口，只具有一个抽象方法，所以在编译期可以很容易推断Lambda表达式和BookFilter是否匹配，于是Lambda表达式的实现就简单了。</p><p>更多例子参见： <a href="http://www.runoob.com/java/java8-functional-interfaces.html" target="_blank" rel="noopener">Java 8 函数式接口</a>; <a href="http://zyzhang.github.io/blog/2013/06/15/java8-preview-functional-interface/" target="_blank" rel="noopener">Java 8 预览之Functional Interface</a></p><h2 id="默认方法（Default-Methods）"><a href="#默认方法（Default-Methods）" class="headerlink" title="默认方法（Default Methods）"></a>默认方法（Default Methods）</h2><p>官方文档给默认方法给出的定义：</p><blockquote><p><a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="noopener">Default methods</a> enable new functionality to be added to the interfaces of libraries and ensure binary compatibility with code written for older versions of those interfaces.</p><p>默认方法允许您添加新的功能到现有库的接口中，并能确保与采用旧版本接口编写的代码的二进制兼容性。</p></blockquote><p>当类实现接口的时候，类要实现接口中所有的方法，否则类必须声明为抽象的类。默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。也就是说，即使你的API已经发布出去了，你依然可以为接口添加新方法并且无需考虑向后兼容问题。</p><p>默认方法是在接口中的方法签名前加上了 <code>default</code> 关键字的实现方法。</p><p>举个例子:</p><pre><code>interface InterfaceA {    default void foo() {        System.out.println(&quot;InterfaceA foo&quot;);    }}class ClassA implements InterfaceA {}public class Test {    public static void main(String[] args) {        new ClassA().foo(); // 打印：“InterfaceA foo”    }}</code></pre><p><code>ClassA</code> 类并没有实现 <code>InterfaceA</code> 接口中的 <code>foo</code> 方法，<code>InterfaceA</code> 接口中提供了 <code>foo</code> 方法的默认实现，因此可以直接调用 <code>ClassA</code> 类的 <code>foo</code> 方法。</p><p>和其它方法一样，接口默认方法也可以被继承，这样一来接口就面临了多继承问题，如下图所示，Interface C 继承了 Interface A 和 B，如果 A 和 B 中存在相同的签名方法，C 就要处理继承冲突的问题。</p><pre><code>+---------------+         +------------+|  Interface A  |         |Interface B |+-----------^---+         +---^--------+            |                 |                     |                 |                     |                 |                     +-+------------+--+                       | Interface C|                          +------------+</code></pre><p>接口多继承冲突分为以下三种情况：</p><ul><li><code>A</code>和<code>B</code>的默认方法（传入参数）不同， C隐式继承了两个默认方法，不会有冲突。</li><li>但是有的情况下即使是不同签名的方法也是很难分辨的，比如传入类型为<code>short</code> 和 <code>int</code>，Java会选择最适合的方法， 请参看 <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5" target="_blank" rel="noopener">Java规范 15.12.2.5</a></li><li>A,B拥有相同签名的默认方法如果接口C没有override这个方法， 则编译出错。这种情况需要在子接口<code>C</code>中覆盖override这个方法，并可以使用 <code>InterfaceName.super.methodName();</code> 的方式手动调用需要的接口默认方法。（注意方法签名不包括方法的返回值， 也就是仅仅返回值不同的两个方法的签名也是相同的）</li></ul><p>更多多继承问题，参见： <a href="http://colobu.com/2014/11/04/Java-8-default-method-and-multiple-inheritance/" target="_blank" rel="noopener">Java 8 默认方法和多继承</a></p><h2 id="重复注解（Repeating-Annotations）"><a href="#重复注解（Repeating-Annotations）" class="headerlink" title="重复注解（Repeating Annotations）"></a>重复注解（Repeating Annotations）</h2><p>自从Java 5中引入<a href="http://www.javacodegeeks.com/2012/08/java-annotations-explored-explained.html" target="_blank" rel="noopener">注解</a>以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。</p><p>例如：</p><pre><code>@Repeatable(Authorities.class)public @interface Authority {     String role();}public @interface Authorities {    Authority[] value();}public class RepeatAnnotationUseNewVersion {    @Authority(role=&quot;Admin&quot;)    @Authority(role=&quot;Manager&quot;)    public void doSomeThing(){ }}</code></pre><p>具体参见：<a href="https://my.oschina.net/benhaile/blog/180932" target="_blank" rel="noopener">Java 8新特性探究（五）重复注解</a></p><h2 id="类型注解（Type-Annotations）"><a href="#类型注解（Type-Annotations）" class="headerlink" title="类型注解（Type Annotations）"></a>类型注解（Type Annotations）</h2><p>在java 8之前，注解只能是在声明的地方所使用，比如类，方法，属性；java 8里面，注解可以应用在任何地方，比如：</p><pre><code>// 创建类实例new @Interned MyObject();// 类型映射       myString = (@NonNull String) str;// implements 语句中        class UnmodifiableList&lt;T&gt; implements @Readonly List&lt;@Readonly T&gt; { ... }// throw exception声明        void monitorTemperature() throws @Critical TemperatureException { ... }</code></pre><p>需要注意的是，类型注解只是语法而不是语义，并不会影响java的编译时间，加载时间，以及运行时间，也就是说，编译成class文件的时候并不包含类型注解。</p><p>类型注解的作用，参见：<a href="https://my.oschina.net/benhaile/blog/179642" target="_blank" rel="noopener">Java 8新特性探究（四）类型注解 复杂还是便捷</a></p><h1 id="（二）Stream"><a href="#（二）Stream" class="headerlink" title="（二）Stream"></a>（二）Stream</h1><p>官方文档对 Collection 的解释：</p><blockquote><p>Classes in the new <code>java.util.stream</code> package provide a Stream API to support functional-style operations on streams of elements. The Stream API is integrated into the Collections API, which enables bulk operations on collections, such as sequential or parallel map-reduce transformations.</p><p><code>java.util.stream</code> 提供了一系列 Stream API 以支持函数式的流式操作。 Stream API 集成在 Collections API 中，它可以对集合进行批量操作，例如串行或并行转换流。</p></blockquote><p>Java 8 中的<em>Stream</em> 是对集合（<em>Collection</em>）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。</p><p>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">Java 8 中的 Streams API 详解</a></p><h2 id="什么是-Stream"><a href="#什么是-Stream" class="headerlink" title="什么是 Stream"></a>什么是 Stream</h2><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的迭代器(Iterator)，单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。而和迭代器又不同的是，Stream 可以并行化操作，且数据源本身可以是无限的。</p><h2 id="Stream-的生命周期"><a href="#Stream-的生命周期" class="headerlink" title="Stream 的生命周期"></a>Stream 的生命周期</h2><p>当我们使用一个流的时候，通常包括三个基本步骤：</p><p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果。</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png" alt=""></p><h3 id="Stream-的构造和转换"><a href="#Stream-的构造和转换" class="headerlink" title="Stream 的构造和转换"></a>Stream 的构造和转换</h3><p><strong>构造流的几种常见方法</strong></p><pre><code>// 1. Individual valuesStream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);// 2. ArraysString [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream();</code></pre><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<integer>、Stream<long>、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</double></long></integer></p><p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p><p><strong>数值流的构造</strong></p><pre><code>IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println);</code></pre><p><strong>数值流的转换</strong></p><p>流转换为其它数据结构：</p><pre><code>// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString();</code></pre><p>### </p><h3 id="Stream-的操作"><a href="#Stream-的操作" class="headerlink" title="Stream 的操作"></a>Stream 的操作</h3><p>Stream 的转换分为以下三种操作类型：</p><ul><li><p><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p><p>包括：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p></li></ul><ul><li><p><strong>Terminal</strong>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p><p>包括：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p></li><li><p>还有一种操作被称为 <strong>short-circuiting</strong>。用以指：</p><ul><li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li><li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li></ul><p>包括：anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><ul><li>Stream 不是数据结构</li><li>所有 Stream 的操作必须以 lambda 表达式为参数</li><li>不支持索引访问，你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。</li><li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li><li>可以是无限的，limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li><li>调用<code>paralle()</code>构造并行stream</li></ul></blockquote><p>更多例子: <a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/" target="_blank" rel="noopener">Java 8 Stream Tutorial Examples</a></p><h2 id="Parallel-Stream"><a href="#Parallel-Stream" class="headerlink" title="Parallel Stream"></a>Parallel Stream</h2><p><strong>Think Twice Before Using Java 8 Parallel Streams</strong></p><p>Stream 的并行功能适用于计算密集且运行在多核操作系统上的应用，而非 IO 密集型。因为Parallel Stream 采用的是 jdk7 中引入的 ForkJoin框架， 使用<strong>分治法(Divide-and-Conquer Algorithm)</strong>管理线程池，这种方案在进程阻塞的情况下会导致事倍功半的效果，相比串行方案还会浪费一些计算资源。</p><p>具体可参见这篇文章：<a href="http://www.jianshu.com/p/bd825cb89e00" target="_blank" rel="noopener">深入浅出parallelStream</a></p><h1 id="（三）新增类库"><a href="#（三）新增类库" class="headerlink" title="（三）新增类库"></a>（三）新增类库</h1><h2 id="Date-Time-Package"><a href="#Date-Time-Package" class="headerlink" title="Date-Time Package"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html" target="_blank" rel="noopener">Date-Time Package</a></h2><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。<br>在旧版的 Java 中，日期时间 API 存在诸多问题，第三方包又些许存在一些兼容性问题，Java 8 在 java.time 包下提供了很多新的 API，包含以下相应的包：</p><ul><li>java.time包：这是新的Java日期/时间API的基础包，所有的主要基础类都是这个包的一部分，如：LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration等等。所有这些类都是不可变的和线程安全的，在绝大多数情况下，这些类能够有效地处理一些公共的需求。</li><li>java.time.chrono包：这个包为非ISO的日历系统定义了一些泛化的API，我们可以扩展AbstractChronology类来创建自己的日历系统。</li><li>java.time.format包：这个包包含能够格式化和解析日期时间对象的类，在绝大多数情况下，我们不应该直接使用它们，因为java.time包中相应的类已经提供了格式化和解析的方法。</li><li>java.time.temporal包：这个包包含一些时态对象，我们可以用其找出关于日期/时间对象的某个特定日期或时间，比如说，可以找到某月的第一天或最后一天。你可以非常容易地认出这些方法，因为它们都具有“withXXX”的格式。</li><li>java.time.zone包：这个包包含支持不同时区以及相关规则的类。</li></ul><h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><p><strong>优雅的空指针处理</strong></p><p>身为一名Java程序员，大家可能都有这样的经历：调用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。这正是一些类似<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Optional.html" target="_blank" rel="noopener">Guava</a>的外部API试图解决的问题。一些JVM编程语言比如Scala、Ceylon等已经将对在核心API中解决了这个问题。新版本的Java，比如<a href="http://blog.sanaulla.info/tag/java-8/" target="_blank" rel="noopener">Java 8</a>引入了一个新的<a href="http://download.java.net/jdk8/docs/api/java/util/Optional.html" target="_blank" rel="noopener">Optional</a>类。Optional类的Javadoc描述如下：</p><blockquote><p>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p></blockquote><p>Optional 类提供了许多方法用于解决空指针的问题，下面列举几个个我认为最常用的方法，完整版可参见这篇文章：<a href="http://www.importnew.com/6675.html" target="_blank" rel="noopener">Java 8 Optional类深度解析</a></p><ul><li><p><strong>ifPresent</strong></p><p>如果Optional实例有值则为其调用consumer，否则不做处理，For example:</p><pre><code>//ifPresent方法接受lambda表达式作为参数。//lambda表达式对Optional的值调用consumer进行处理。name.ifPresent((value) -&gt; {  System.out.println(&quot;The length of the value is: &quot; + value.length());});</code></pre></li><li><p><strong>orElse</strong></p><p>如果Optional实例有值则将其返回，否则返回orElse方法传入的参数，For example：</p><pre><code>//如果值不为null，orElse方法返回Optional实例的值。//如果为null，返回传入的消息。//输出：There is no value present!System.out.println(empty.orElse(&quot;There is no value present!&quot;));//输出：SanaullaSystem.out.println(name.orElse(&quot;There is some value!&quot;));</code></pre></li><li><p><strong>orElseGet</strong></p><p>orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受<a href="http://blog.sanaulla.info/2013/04/02/supplier-interface-in-java-util-function-package-in-java-8/" target="_blank" rel="noopener">Supplier接口</a>的实现用来生成默认值，For example：</p><pre><code>//orElseGet与orElse方法类似，区别在于orElse传入的是默认值，//orElseGet可以接受一个lambda表达式生成默认值。//输出：Default ValueSystem.out.println(empty.orElseGet(() -&gt; &quot;Default Value&quot;));//输出：SanaullaSystem.out.println(name.orElseGet(() -&gt; &quot;Default Value&quot;));</code></pre></li><li><p><strong>map</strong></p><p>如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional，For example：</p><pre><code>//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());System.out.println(upperName.orElse(&quot;No value found&quot;));</code></pre></li></ul><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>在Java 8中，Base64编码已经成为Java类库的标准。<br>Java 8 内置了 Base64 编码的编码器和解码器。<br>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p><ul><li>基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li><li>URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li><li>MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li></ul><h2 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a><a href="http://docs.oracle.com/javase/8/javase-clienttechnologies.htm" target="_blank" rel="noopener">JavaFX</a></h2><p>JavaFX主要致力于富客户端开发，以弥补swing的缺陷，主要提供图形库与media库，支持audio,video,graphics,animation,3D等，同时采用现代化的css方式支持界面设计。</p><p>具体可参见：<a href="https://my.oschina.net/benhaile/blog/335109" target="_blank" rel="noopener">Java 8新特性探究（十三）JavaFX 8新特性以及开发2048游戏</a></p><h1 id="（四）JVM-升级"><a href="#（四）JVM-升级" class="headerlink" title="（四）JVM 升级"></a>（四）<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/" target="_blank" rel="noopener">JVM</a> 升级</h1><p>JVM 为了方便内存回收将堆内存分为<strong>新生代（Young generation）</strong>， <strong>老年代（Old generation）</strong>， <strong>持久代（ permanent generation ）</strong>（如下图所示）具体参考：<a href="http://www.importnew.com/1993.html" target="_blank" rel="noopener">成为JavaGC专家（1）—深入浅出Java垃圾回收机制</a></p><p><img src="http://www.importnew.com/wp-content/uploads/2012/12/Figure-1-GC-Area-Data-Flow.png" alt=""></p><p>Java8 移除了 Permanent Generation，取而代之的是一个叫 MetaSpace（元空间） 的内存空间（如下图所示），MetaSpace 使用的是本地内存（Native heap），带来的最大好处是不会再有  <a href="http://javaeesupportpatterns.blogspot.com/2011/02/outofmemoryerror-permgen-patterns-part1.html" target="_blank" rel="noopener">java.lang.OutOfMemoryError: PermGen</a> 的问题，MetaSpace 回根据使用情况自动扩容，其理论最大值即为操作系统所能提供的内存最大值；另外 MetaSpace 的 GC 扫描只会发生在 MetaSpace 达到 MaxMetaspaceSize 设置的上限的时候，减少 GC 扫描次数在一定程度上优化了 JVM 的性能。</p><p>具体参照：<a href="https://dzone.com/articles/java-8-permgen-metaspace" target="_blank" rel="noopener">Java 8: From PermGen to Metaspace</a></p><p>关于 JVM 是什么：<a href="http://www.jianshu.com/p/28639d7a00fe" target="_blank" rel="noopener">【转】JVM介绍——不得不知的JVM</a></p><p><img src="http://static.oschina.net/uploads/space/2014/0329/195605_gspc_1028150.png" alt=""></p><h1 id="（五）新工具"><a href="#（五）新工具" class="headerlink" title="（五）新工具"></a>（五）新工具</h1><p>新的编译工具，如：Nashorn JavaScript引擎 jjs、 类依赖分析器jdeps。具体参见：<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/enhancements-8.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="Nashorn-JavaScript-引擎"><a href="#Nashorn-JavaScript-引擎" class="headerlink" title="Nashorn JavaScript 引擎"></a>Nashorn JavaScript 引擎</h2><p>Nashorn 一个 javascript 引擎。<br>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。</p><p>更多参见：<a href="https://my.oschina.net/benhaile/blog/290276" target="_blank" rel="noopener">Java 8新特性探究（十二）Nashorn ：新犀牛</a></p><h1 id="（六）安全"><a href="#（六）安全" class="headerlink" title="（六）安全"></a>（六）<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/enhancements-8.html" target="_blank" rel="noopener">安全</a></h1><p>众多安全性上的提提升，如更好的 TSL/SSL 支持，改进加密算法等等，具体参见<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/enhancements-8.html" target="_blank" rel="noopener">官方文档</a></p><hr><h1 id="云时代-Java"><a href="#云时代-Java" class="headerlink" title="云时代 Java"></a>云时代 Java</h1><p>最开始接触 Java 了解到 Java 最大的优势（也是 Java 诞生的初衷）就是它的跨平台性和易于移植，其实 JVM 也是一种容器，但是这种容器特性正在被Linux学习与赶超，Docker 之类容器可以在本地笔记本或电脑上运行，然后同样可以部署到云上运行。当在云上运行时，Kubernetes 能够以一种可控的方式升级容器从而实现运行管理一批容器，如同一个大型船队或舰队一样，你可以控制它们的流量访问量，可以指定多少个容器来扩展支撑一个服务的运行，随着访问量提升，你通过增加容器数量能够整个系统的负载能力。</p><p>当然，Java 的大型分布式系统越来越多，Java在云计算与分布式系统中还是扮演主要角色，形成一个大型的生态圈。当我们站在泰山之上，一览众山小，当你在全球拥有多个数据中心时，语言已经变得不那么重要了，关键是架构设计。</p><blockquote><p>Refer:</p><ul><li><a href="http://www.importnew.com/9060.html" target="_blank" rel="noopener">Java的历史</a></li><li><a href="http://www.infoq.com/cn/news/2015/05/java-20-history-future" target="_blank" rel="noopener">Java 20年：历史与未来</a></li><li><a href="https://my.oschina.net/benhaile/blog?sort=time&amp;catalog=410404&amp;p=2&amp;temp=1503637545998" target="_blank" rel="noopener">成熟的毛毛虫：Java8</a></li><li><a href="http://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">http://www.runoob.com/java/java8-new-features.html</a></li><li><a href="http://blog.oneapm.com/apm-tech/226.html" target="_blank" rel="noopener">深入浅出 Java 8 Lambda 表达式</a></li><li><a href="https://www.codementor.io/eh3rrera/using-java-8-method-reference-du10866vx" target="_blank" rel="noopener">Java 8 Method Reference: How to Use it</a></li><li><a href="http://colobu.com/2014/10/28/secrets-of-java-8-functional-interface/" target="_blank" rel="noopener">http://colobu.com/2014/10/28/secrets-of-java-8-functional-interface/</a></li><li><a href="http://blog.csdn.net/zxhoo/article/details/38349011" target="_blank" rel="noopener">http://blog.csdn.net/zxhoo/article/details/38349011</a></li><li><a href="http://ebnbin.com/2015/12/20/java-8-default-methods/" target="_blank" rel="noopener">http://ebnbin.com/2015/12/20/java-8-default-methods/</a></li><li><a href="https://nkcoder.github.io/2016/01/24/java-8-stream-api/" target="_blank" rel="noopener">https://nkcoder.github.io/2016/01/24/java-8-stream-api/</a></li><li><a href="http://www.jianshu.com/p/5b800057f2d8" target="_blank" rel="noopener">http://www.jianshu.com/p/5b800057f2d8</a></li><li><a href="http://www.importnew.com/14140.html" target="_blank" rel="noopener">http://www.importnew.com/14140.html</a></li><li><a href="http://brianway.github.io/2017/03/29/javase-java8/" target="_blank" rel="noopener">http://brianway.github.io/2017/03/29/javase-java8/</a></li><li><a href="http://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="noopener">http://www.sczyh30.com/posts/Java/jvm-metaspace/</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 从 1995年正式发布第一个版本至今已走过 21 个年头，从一开始受人怀疑的慢语言发展为如今通用的健壮语言。笔者 11 年开始接触 Java1.6 到后来转投 Python，再转向云架构，而今因项目需求再次拾起 Java 已经过了两次版本更新，借项目上的机会，将 
      
    
    </summary>
    
      <category term="Java" scheme="https://www.duyidong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.duyidong.com/tags/Java/"/>
    
      <category term="代码" scheme="https://www.duyidong.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>DevOps 从理论到实践</title>
    <link href="https://www.duyidong.com/2017/07/14/what-is-devops/"/>
    <id>https://www.duyidong.com/2017/07/14/what-is-devops/</id>
    <published>2017-07-14T10:35:34.000Z</published>
    <updated>2017-07-16T11:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周六应邀参加了 <a href="https://www.freecodecamp.org/" target="_blank" rel="noopener">FreeCodeCamp</a>社区的一次线下活动，主题为《DevOps从理论到实践》，借此机会整理一下近年来看到听到的对于 DevOps 的定义，并产出一些自己的观点。</p><h1 id="什么是DevOps"><a href="#什么是DevOps" class="headerlink" title="什么是DevOps"></a>什么是DevOps</h1><h2 id="DevOps-是一个流行词"><a href="#DevOps-是一个流行词" class="headerlink" title="DevOps 是一个流行词"></a>DevOps 是一个流行词</h2><p><img src="/images/devops_word_cloud.png" alt=""></p><p>如今 DevOps 已经成为一个流行词，很多公司都在说自己在做 DevOps，但是每个人、每家公司理解的 DevOps 又不尽相同，从 DevOps 诞生的第一天起，如何定义 DevOps 就是一个争论不休的话题。</p><p>这里有一篇文章，笔者认为基本诠释了 DevOps 的定义：<a href="https://mp.weixin.qq.com/s?__biz=MzI3OTEzNjI1OQ==&amp;mid=2651492848&amp;idx=1&amp;sn=1a644a2624633489248dda2834dc9572&amp;chksm=f0b2609cc7c5e98a0145eead91b68db41d18dc33bc1be46f08026d1746b1063a6c177b7daf24#rd" target="_blank" rel="noopener">DevOps 是什么不是什么</a></p><p>如果你没有耐心把这篇文章看完，<a href="https://en.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">维基百科</a>还给出了一个太长不读版：</p><blockquote><p> DevOps (a clipped compound of “development” and “operations”) is a software development and delivery process that emphasizes communication and collaboration between product management, software development, and operations professionals.It seeks to automate the process of software integration, testing, deployment, and infrastructure changes by establishing a culture and environment where building, testing, and releasing software can happen rapidly, frequently, and more reliably.</p></blockquote><p>归纳成三点：</p><ul><li>DevOps 是一种强调沟通与协作的软件交付过程。它包括产品管理，软件开发及运营等各个方面。</li><li>DevOps 自动化软件集成，测试，部署以及基础设施的变更。</li><li>它的目标是建立一种文化和环境，使得软件的构建、测试、交付更快，更频繁，更可靠。</li></ul><p><img src="/images/dev_ops_qa.png" alt=""></p><h2 id="DevOps-的由来"><a href="#DevOps-的由来" class="headerlink" title="DevOps 的由来"></a>DevOps 的由来</h2><p>参见 <a href="http://www.jianshu.com/p/f40209023006" target="_blank" rel="noopener">DevOps编年史</a> 和一个 Youtube 小视频： <a href="https://www.youtube.com/watch?v=o7-IuYS0iSE" target="_blank" rel="noopener">The (Short) History of DevOps</a> </p><p><img src="/images/history_of_devops.png" alt=""></p><p>这里我想多提一句的是持续交付和 DevOps 的关系和差别，参照<a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="noopener">维基百科</a> 对 DevOps 和持续交付的区别进行解释，DevOps 涵盖的范围比持续交付更宽，它包含了文化，强调团队协作和自动化；而持续交付侧重于频繁、快速     地执行交付流程，两者相辅相成，却又有所区别。</p><blockquote><p>Continuous delivery and DevOps are similar in their meanings and are often conflated, but they are two different concepts. DevOps has a broader scope, and centers around the cultural change, specifically the collaboration of the various teams involved in software delivery (developers, operations, quality assurance, management, etc.), as well as automating the processes in software delivery.Continuous delivery, on the other hand, is an approach to automate the delivery aspect, and focuses on bringing together different processes and executing them more quickly and more frequently. Thus, DevOps can be a product of continuous delivery, and CD flows directly into DevOps.</p></blockquote><h2 id="DevOps-理论框架"><a href="#DevOps-理论框架" class="headerlink" title="DevOps 理论框架"></a>DevOps 理论框架</h2><p>因为DevOps源自草根，缺乏自上而下的理论支撑，所以如何定义 DevOps 成了 DevOps 社区里面的一个大难题。一些 DevOps 从业者，纷纷设定自己的 DevOps 框架。其中比较有名的框架有Damon Edwards所定义并被 Jez Humble（持续交付作者之一） 所修订的<a href="https://blog.rackspace.com/quantifying-devops-capability-its-important-to-keep-calms" target="_blank" rel="noopener">CALMS</a>，和Gene Kim所定义的<a href="https://www.duyidong.com/2017/07/12/the-three-ways-understanding-devops/">The Three Ways</a>。</p><h3 id="The-Three-Ways"><a href="#The-Three-Ways" class="headerlink" title="The Three Ways"></a>The Three Ways</h3><ul><li><strong>The First Way：</strong> System Thinking （系统思考：强调全局优化，避免局部优化）</li><li><strong>The Second Way：</strong> Amplify Feedback Loops （经过放大的反馈回路：创建从开发过程下游至上游的反馈环）</li><li><strong>The Third Way：</strong> Culture of Continual Experimentation And Learning（持续做试验和学习的文化：持续做试验，承担风险、从失败中学习；通过反复实践来达到精通）</li></ul><p><img src="/images/devops_CALMS_model.png" alt=""></p><h3 id="CLAMS"><a href="#CLAMS" class="headerlink" title="CLAMS"></a>CLAMS</h3><ul><li><strong>Culture – 文化：</strong>公司各个角色一起担当业务变化，实现有效协作和沟通；建立包括运维在内的跨职能协作文化,具有共同目标的一体化团队。这是DevOps运动的根本</li><li><strong>Automation – 自动化：</strong>在价值链中尽量除去手工步骤；自动化一切可以自动化的步骤，降低部署和发布的难度</li><li><strong>Lean – 精益：</strong>运用精益原则更频繁地交付价值；以精益的方式小步快跑，对过程与技术进行持续改善</li><li><strong>Metrics – 度量：</strong>度量并使用数据来优化交付周期；通过建立有效的监控与度量手段来获得反馈,推动产品和团队的持续改进, 支持业务决策</li><li><strong>Sharing – 分享：</strong>分享成功和失败的经验来相互学习。</li></ul><h1 id="为什么要实践-DevOps"><a href="#为什么要实践-DevOps" class="headerlink" title="为什么要实践 DevOps"></a>为什么要实践 DevOps</h1><p>了解了 DevOps 的历史，再来看为什么要实践 DevOps，笔者认为主要有以下三点：</p><ul><li>更短的交付周期，生产环境部署频率越来越快，简化生产部署流程，且自动化不停机部署</li><li>更高的价值，形成特性提出到运营数据、用户反馈验证的实验性交付闭环，基于实际用户反馈调整计划和需求</li><li>更好的质量保障，在代码检查，功能和非功能验证，以及部署各方面建立较完善的质量保障体系，尤其是自动化测试集</li><li>更高绩效的团队，包含业务，开发测试，和运维职能在内的一体化团队，以产品交付为共同目标紧密协作，共同承担责任</li></ul><h1 id="DevOps-在技术领域的实践"><a href="#DevOps-在技术领域的实践" class="headerlink" title="DevOps 在技术领域的实践"></a>DevOps 在技术领域的实践</h1><p>DevOps运作包括<strong>文化</strong>（全功能，自运维）和<strong>技术</strong>（自动化，度量反馈）两方面，而技术能力的改进主要关注以下六个领域：</p><p><img src="/images/devops_practice.png" alt=""></p><h3 id="内建质量体系"><a href="#内建质量体系" class="headerlink" title="内建质量体系"></a>内建质量体系</h3><p>通过持续代码评审，静态分析，自动化测试，自动部署验证等手段构成一套有效的质量保障体系。</p><p>主要实践包括：</p><ul><li>TDD：测试驱动开发的思想，保证代码质量和不偏离业务需求的技术实现</li><li>结对编程和代码审查，依靠团队的自治性让团队成员互相监督和审查代码质量</li><li>自动化测试，高自动化，且高频率运行的测试，保证测试用例质量的同时保证了交付软件的质量</li></ul><h3 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h3><p>通过自动化的构建，部署过程快速频繁地将软件交付给用户，提高吞吐量；同时保障过程的安全，平滑，可视。</p><p>主要实践包括：</p><ul><li>在已经做到持续集成的情况下，引入持续部署，每次提交均会出发构建并执行部署</li><li>蓝绿部署，用于实现零宕机发布新版本</li><li>金丝雀发布，用于使应用发布流程具备快速试错的能力</li></ul><h3 id="持续监控"><a href="#持续监控" class="headerlink" title="持续监控"></a>持续监控</h3><p>持续对运行环境在系统，应用层面进行监控，及时发现风险或问题，保障系统运行的稳定性。</p><p>主要实践包括：</p><ul><li>监控预警，在项目开始初期就引入监控，让整个团队实时能够收到关于产品各个维度数据的反馈</li><li>日志聚合，便于错误追踪和展示</li><li>分析，利用搜集到的数据实时分析，利用分析结果指导开发进度</li></ul><h3 id="度量与反馈"><a href="#度量与反馈" class="headerlink" title="度量与反馈"></a>度量与反馈</h3><p>通过对用户行为或业务指标的度量或反馈收集，为产品的决策提供依据。</p><p>主要实践包括：</p><ul><li>持续集成反馈，对代码构建质量，代码质量审查的反馈</li><li>测试反馈，对软件质量，功能性的测试，给到业务的反馈</li><li>运营数据反馈，新功能上线后对业务影响的反馈，用于指导业务人员提新的需求</li></ul><h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><p>通过对服务器环境的定义，自动化建立和配置、更新等提高基础设施管理的效率，一致性，并更有效利用资源，可伸缩的架构，保证服务的健壮性。</p><p>主要实践包括：</p><ul><li>弹性架构，保证服务的吞吐量和具备灵活变更的能力</li><li>自动化部署脚本，想胶水一样，用于解决一些工程实践不够完善的流程之间的衔接</li><li>基础设施即代码，用代码定义基础设施，便于环境管理，追踪变更，以及保证环境一致性</li></ul><h3 id="松耦合架构"><a href="#松耦合架构" class="headerlink" title="松耦合架构"></a>松耦合架构</h3><p>对传统应用架构进行领域组件化，服务化，提升可测试性和可部署性。</p><p>主要实践包括：</p><ul><li>采用弹性基础设施，比如公有云服务或是 PaaS（Platform as a Service） 平台</li><li>构建为服务应用</li><li>引入契约测试</li></ul><p><img src="/images/devops_full_picture.png" alt=""></p><center><strong>典型DevOps的持续交付流水线全景图</strong></center><p><img src="/images/devops_pipeline.png" alt=""></p><center><strong>软件开发全生命周期的持续优化</strong></center><h1 id="未来-amp-趋势"><a href="#未来-amp-趋势" class="headerlink" title="未来 &amp; 趋势"></a>未来 &amp; 趋势</h1><ul><li><p><strong>DevOps 话语权越来越多被平台厂商掌握</strong></p><p>​    在 DevOps 实践的第一阶段，往往会是 Jenkins, Nexus, Ansible, Shell 等一系列工具的拼凑组合，上手难度大，维护成本高，开发体验不好。随着 DevOps 日渐成熟，以 AWS、Pivotal、RedHat 为代表的一些公司分别退出自己的 “DevOps产品”，或是一套完整的工具链，或者直接整合到一个 PaaS 平台，甚至一些产品直接将“敏捷”，“精益”的概念也整合到产品中，直接可以把一家公司的全部业务放到平台上，这和最近大热的“数字化平台战略”也是相吻合的。</p><p>​    不管怎样，这些平台厂商一边卖自己的产品一边重新定义着 DevOps，随着平台的完善，DevOps 已经变得越来越不重要，我一直觉得最好的 DevOps  团队应该是“润物细无声”的，就是一个团队不用提 DevOps，整个团队很自然地就能关注到业务价值的交付，且能有序地按照高质量，高效率的要求去做，平台或许能帮助我们做到这一点。</p></li><li><p><strong>容器化 &amp;  微服务仍然是 DevOps 应用和发展的主要领域</strong></p><p>​    容器化、微服务天然适合小而全的功能团队，且一个个自治的服务也很复合 DevOps 端到端交付团队的设计，近年随着容器化技术（Docker）的发展，容器管理（Kubernetes）的日渐成熟（据悉，github 已经将它们的一部分产品环境灰度发布到了 kubernetes 上，京东也将他们的服务百分之六十采用了 kubernetes 管理），DevOps 和微服务成为了相辅相成的两个趋势。</p></li><li><p><strong>安全成为推动 DevOps 全面发展的重要力量</strong></p><p>​    安全是 DevOps 永远绕不开的话题，也往往是新技术在传统行业（例如金融和电信）应用中的最大阻碍。一方面，组织结构的转型迫使企业要打破原先的部门墙，这意味着很多原先的控制流程不再适用。另一方面，由于大量的 DevOps 技术来源于开源社区，缺乏强大技术实力的企业在应用相关技术时不免会有所担忧。</p><p>​    DevOps 全局优化的特点与安全社区提出的 “Build Security In”也特别吻合，加之越来越多安全易用的工具涌现，DevOpsSec 会越来越被人们熟知。</p></li></ul><blockquote><p>参考资料：</p><p><a href="http://insights.thoughtworkers.org/instantiate-the-principles-of-devops/" target="_blank" rel="noopener">http://insights.thoughtworkers.org/instantiate-the-principles-of-devops/</a></p><p><a href="http://www.jianshu.com/p/5781489e8431" target="_blank" rel="noopener">http://www.jianshu.com/p/5781489e8431</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本周六应邀参加了 &lt;a href=&quot;https://www.freecodecamp.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FreeCodeCamp&lt;/a&gt;社区的一次线下活动，主题为《DevOps从理论到实践》，借此机会整理一下近年来看到
      
    
    </summary>
    
      <category term="DevOps" scheme="https://www.duyidong.com/categories/DevOps/"/>
    
    
      <category term="持续交付" scheme="https://www.duyidong.com/tags/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    
      <category term="DevOps" scheme="https://www.duyidong.com/tags/DevOps/"/>
    
      <category term="敏捷" scheme="https://www.duyidong.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
      <category term="DevOps文化" scheme="https://www.duyidong.com/tags/DevOps%E6%96%87%E5%8C%96/"/>
    
      <category term="CALMS" scheme="https://www.duyidong.com/tags/CALMS/"/>
    
  </entry>
  
  <entry>
    <title>DevOps的三种方式</title>
    <link href="https://www.duyidong.com/2017/07/12/the-three-ways-understanding-devops/"/>
    <id>https://www.duyidong.com/2017/07/12/the-three-ways-understanding-devops/</id>
    <published>2017-07-12T14:50:38.000Z</published>
    <updated>2017-07-13T11:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://itrevolution.com/author/gene-kim/" target="_blank" rel="noopener">Gene Kim</a> 的博客 <a href="http://itrevolution.com/the-three-ways-principles-underpinning-devops/" target="_blank" rel="noopener">The Three Ways: The Principles Underpinning DevOps</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客中提到的“三种方式“源自 <a href="http://www.itrevolution.com/book/the-devops-handbook/" target="_blank" rel="noopener">《DevOps Handbook》</a> 及《凤凰项目》（<a href="https://itrevolution.com/books/novel/" target="_blank" rel="noopener">The Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Win.</a>），这三种方式描述了构成 DevOps 的理论框架、流程、实践及价值观和哲学。</p><p>感谢《Lean IT》的作者 Mike Orzen 为此文提供宝贵建议。</p><h1 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h1><p>下文将介绍三种模式及在该种模式指导下的 DevOps 实践。</p><h2 id="第一种方式：-系统思考"><a href="#第一种方式：-系统思考" class="headerlink" title="第一种方式： 系统思考"></a>第一种方式： 系统思考</h2><p><img src="https://itrevolution.com/wp-content/uploads/2012/08/first-way2-400x191.png" alt=""></p><p>第一种方式强调<strong>全局优化，而非局部改进</strong>。— 大到部门职能划分（例如研发部和运维部门），小到个人（开发和系统工程师）。</p><p>这种方式将关注点放在整个业务价值流上。换句话说，整个团队应该关注在从需求被定义到开发，再到运维这个过程，直到价值被以服务的形式交付给最终用户。</p><p>将这种方式带到实践中的产出便是永远不要将已知的缺陷传递到下游工作，永远不要为了局部优化影响了整体价值流交付，总是为了增加价值流动努力，永远追求对架构的深刻理解。</p><p>涉及到这种方式的实践有：</p><ul><li>所有环境和代码使用同一个仓库，将软件包纳入版本管理</li><li>团队共同决定发布流程</li><li>保持 DEV、TEST、PRODUCTION 环境的一致性</li><li>自动化回归测试</li><li>小步提交，每日部署；而不是一次部署大量变更</li><li>更快、更频繁发布</li></ul><h2 id="第二种方式：经过放大的反馈回路"><a href="#第二种方式：经过放大的反馈回路" class="headerlink" title="第二种方式：经过放大的反馈回路"></a>第二种方式：经过放大的反馈回路</h2><p><img src="https://itrevolution.com/wp-content/uploads/2012/08/second-way1-400x211.png" alt=""></p><p>第二种方式是<strong>创建从开发过程下游至上游的反馈环</strong>。几乎所有的流程改进都是为了从时间上缩短和从覆盖面上放大反馈循环，从而可以不断地进行必要的改正。</p><p>第二种方式的产出是关注到价值流中所有涉及到的用户，包括价值流内部和外部的，缩短和放大反馈回路，并且可以随时定位到需要改进的地方。</p><p>涉及到这种方式的实践有：</p><ul><li>代码审查及配置变更检查</li><li>有纪律的自动化测试，使许多同时的小型敏捷团队能够有效地工作</li><li>尽早设置监控预警</li><li>修复 bug 为团队最高优先级</li><li>团队成员之间高度互相信任</li><li>团队之间保持沟通和良好合作</li></ul><h2 id="第三种方式：持续做试验和学习的文化"><a href="#第三种方式：持续做试验和学习的文化" class="headerlink" title="第三种方式：持续做试验和学习的文化"></a>第三种方式：持续做试验和学习的文化</h2><p><img src="https://itrevolution.com/wp-content/uploads/2012/08/third-way-400x224.png" alt=""></p><p>第三种方式提倡<strong>持续做试验，承担风险、从失败中学习；通过反复实践来达到精通</strong>。</p><p>我们需要实验和冒着失败的风险，及时不断地尝试将我们置于一个危险的境地，我们要通过反复试错来掌握使我们远离危险的技能。</p><p>第三种方式的输出为为改善日常工作分配时间、奖励团队冒险精神，将错误人工引入系统以提高系统健壮性。</p><p>最具有代表性的就是 Netfilx 的 Chaos monkey ，Netflix 在他们的生产环境搭建一个服务用于定时随机关闭服务器，用以模拟服务器正常损坏或服务异常，他们的系统长期在这种环境下运行，“服务器故障”成为系统每日都要面临的问题，因此当服务器真的以外故障时不会对系统整体造成任何的影响。</p><h1 id="译者后记"><a href="#译者后记" class="headerlink" title="译者后记"></a>译者后记</h1><p>全局优化、快速反馈、鼓励失败。我们发现其实敏捷、精益、持续交付、DevOps中间有很多相似的东西。</p><blockquote><p>参考资料: <a href="https://es.slideshare.net/SonatypeCorp/devops-connect-josh-corman-and-gene-kim-discuss-devopssec" target="_blank" rel="noopener">https://es.slideshare.net/SonatypeCorp/devops-connect-josh-corman-and-gene-kim-discuss-devopssec</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文翻译自 &lt;a href=&quot;https://itrevolution.com/author/gene-kim/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gene Kim&lt;/a&gt; 的博客 &lt;a href=&quot;http://itrevolution.co
      
    
    </summary>
    
      <category term="DevOps" scheme="https://www.duyidong.com/categories/DevOps/"/>
    
    
      <category term="翻译" scheme="https://www.duyidong.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="DevOps" scheme="https://www.duyidong.com/tags/DevOps/"/>
    
      <category term="理论框架" scheme="https://www.duyidong.com/tags/%E7%90%86%E8%AE%BA%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>如何制作在线幻灯片</title>
    <link href="https://www.duyidong.com/2017/06/20/reveal-js-quick-start/"/>
    <id>https://www.duyidong.com/2017/06/20/reveal-js-quick-start/</id>
    <published>2017-06-20T08:20:33.000Z</published>
    <updated>2017-06-20T09:17:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>都说不会做幻灯片的程序员不是好架构师，工作中有很多场合需要用到幻灯片。最近在准备一个对外分享，内容比较简单，顺手尝试了一下使用 <code>reveal js</code>制作一个在线幻灯片。</p><p>效果展示：<a href="https://cdn.rawgit.com/ADU-21/cd-in-cloud-reveal-js/784e1a49/index.html" target="_blank" rel="noopener">https://cdn.rawgit.com/ADU-21/cd-in-cloud-reveal-js/784e1a49/index.html</a></p><p>这个幻灯片中包含文本、图片、视频，下面我会逐一讲解是如何实现的。</p><h1 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h1><ul><li>解决微软的 PowerPoint 和 Mac keynote 跨平台不兼容问题</li><li>传统幻灯片需要拷来拷去，在线幻灯片只需要一个 URL 就可以访问，避免忘带 U 盘的尴尬</li><li>在线幻灯片本质上是 html 文件，也可以在无网络环境播放</li></ul><h1 id="用到的资源"><a href="#用到的资源" class="headerlink" title="用到的资源"></a>用到的资源</h1><ul><li><a href="http://lab.hakim.se/reveal-js/#/" target="_blank" rel="noopener">reveal js</a> ：将幻灯片文本内容渲染为 html</li><li><a href="https://github.com/" target="_blank" rel="noopener">github</a> : 用于存放幻灯片文件</li><li><a href="http://rawgit.com/" target="_blank" rel="noopener">rawgit</a> : 将 GitHub 中的 html 正常加载，并添加 CDN </li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="第一步：-Fork-官方-Repo"><a href="#第一步：-Fork-官方-Repo" class="headerlink" title="第一步： Fork 官方 Repo"></a>第一步： Fork 官方 Repo</h2><p>前往<a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">https://github.com/hakimel/reveal.js</a> 点击 <code>fork</code>将代码复制到自己账号下。</p><pre><code>git clone https://github.com/&lt;you account id&gt;/reveal.js</code></pre><p>这时你就得到了一个可运行的 reveal js 模板，运行根目录下的 index.html 即可预览。</p><p><a href="https://github.com/hakimel/reveal.js/blob/master/README.md" target="_blank" rel="noopener">README</a> 中提供了很多配置编辑的方式，你要是没耐心看就跟着我继续吧。</p><h2 id="第二步：-编辑-index-html"><a href="#第二步：-编辑-index-html" class="headerlink" title="第二步： 编辑 index.html"></a>第二步： 编辑 index.html</h2><p>找到<code>&lt;div class=&quot;slides&quot;&gt;</code> ，这里是幻灯片正文的开始，在这个标签中添加如下代码，开启 <code>markdown</code>编辑模式：</p><pre><code>&lt;section data-markdown data-separator=&quot;---&quot; data-separator-vertical=&quot;--&quot;&gt;    &lt;script type=&quot;text/template&quot;&gt;    ### 正文在此    &lt;/script&gt;&lt;/section&gt;</code></pre><p>现在你可使用 markdown 语法开始编辑幻灯片内容了。</p><h3 id="基本编辑方式"><a href="#基本编辑方式" class="headerlink" title="基本编辑方式"></a>基本编辑方式</h3><p><code>---</code> 表示横向分页。</p><p><code>--</code> 表示竖向分页，通常一列可以作为一个章节。</p><p><code># 标题</code> <code>- 列表</code></p><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>插入图片有两种方式，基本的插入 markdown 语法就可以支持：</p><p><code>![](https://hostname.com/image.png)</code> 外部引用。</p><p>考虑到一些时候我们需要在无网络的情况下播放 幻灯片，所以通常还是将图片保存到本地再添加。</p><p><code>![](images/image.png)</code> 这种方式需要在根目录下创建一个叫 image 的文件夹，把图片放入其中命名为 imag.png。</p><p>如果要对图片又更复杂的支持，比如调整长宽，则需要写 html 代码，如：</p><p><code>&lt;img src=&quot;images/image.jpg&quot; alt=&quot;&quot; width=&quot;500px&quot;&gt;</code></p><h3 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h3><p>以 youtube 视频为例，首先使用 youtube-dl 下载视频：</p><pre><code>brew install youtube-dl                     # 安装 youtube-dlyoutube-dl https://www.youtube.com/watch?v=oHg5SJYRHA0</code></pre><p>下载视频默认格式为 webm 格式，这是一种支持 HTML5 的视频文件格式，可以使用浏览器打开，将视频添加到幻灯片中：</p><pre><code>&lt;section data-background-video=&quot;your_video_name.webm&quot;&gt;</code></pre><p>幻灯片 播放到这一页的时候就会开始自动播放视频。</p><h2 id="第三步：-对外访问"><a href="#第三步：-对外访问" class="headerlink" title="第三步： 对外访问"></a>第三步： 对外访问</h2><p>将编辑好后的 reveal js 这个项目提交到 GitHub 上：</p><pre><code>git add .git commit -m &quot;add my slides&quot;git push origin master</code></pre><p>从网页访问你的 repo，以示例中的幻灯片为例： <a href="https://github.com/ADU-21/cd-in-cloud-reveal-js/blob/master/index.html" target="_blank" rel="noopener">https://github.com/ADU-21/cd-in-cloud-reveal-js/blob/master/index.html</a> ，我们发现幻灯片并没有被正常渲染，而是以源代码的方式展示。这个时候就需要用到第三方工具将 github 代码库中的 html 文件按照期望的方式对外暴露使其访问，具体操作：</p><ul><li>打开 <a href="http://rawgit.com/" target="_blank" rel="noopener">http://rawgit.com/</a></li><li>在中间的输入框输入 <code>https://github.com/&lt;your github id&gt;/cd-in-cloud-reveal-js/blob/master/index.html</code></li><li>得到 <code>production url</code> 和 <code>development url</code>两个链接</li></ul><p>Production url 是带有 CDN 的，和 github 的同步会存在一定的延迟， developement url 的更新会及时一些，不过访问速度相对会没那么快。</p><p>现在访问生成的 URL，你的在线幻灯片就已经制作完毕。</p><p>以上，不一定是最佳实践，不过经笔者亲测，行之有效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;都说不会做幻灯片的程序员不是好架构师，工作中有很多场合需要用到幻灯片。最近在准备一个对外分享，内容比较简单，顺手尝试了一下使用 &lt;code&gt;reveal js&lt;/code&gt;制作一个在线幻灯片。&lt;/p&gt;
&lt;p&gt;效果展示：&lt;a href=&quot;https://cdn.rawgit.
      
    
    </summary>
    
      <category term="工具" scheme="https://www.duyidong.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.duyidong.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="reveal js" scheme="https://www.duyidong.com/tags/reveal-js/"/>
    
      <category term="在线幻灯片" scheme="https://www.duyidong.com/tags/%E5%9C%A8%E7%BA%BF%E5%B9%BB%E7%81%AF%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>PaaS 平台（三）-- Openshift 使用</title>
    <link href="https://www.duyidong.com/2017/06/15/openshift-quick-start/"/>
    <id>https://www.duyidong.com/2017/06/15/openshift-quick-start/</id>
    <published>2017-06-15T10:27:41.000Z</published>
    <updated>2017-09-17T05:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Openshift 是一个基于 Kubernetes 和 Docker 的 PaaS 平台。</p><h1 id="Openshift-概念补充"><a href="#Openshift-概念补充" class="headerlink" title="Openshift 概念补充"></a>Openshift 概念补充</h1><p>我们在上文–<a href="https://www.duyidong.com/2017/06/15/kubernetes-infrastructure/">Kubernetes 介绍</a>中已经提到 Kubernetes 引入了一些概念，Openshift 在此基础之上又对这些概念进行了封装。了解 Openshift 除了了解它的架构以外，还要了解他抽象出来的概念。</p><ul><li><strong>ImageStream:</strong> 对 Docker Image 的抽象，Docker image 只是一个二进制文件实体，而 ImageStream 可以带有状态，可以对外部程序的访问做出相应。</li><li><strong>BuildConfig:</strong> 对 Dockerfile 的抽象，上文已经说到 Openshift 中的 Pod 实际上是由多个 Container 构成的，这些 Conatainer 仍然是运行时的 Image，这些 Image 的构建过程就是由 BuildConfig 决定的，不同于 Dockerfile，BuildConfig 可以支持将 gitrepo, Dockerfile, Binary, Image, Input Secrite(Openshift 定义的另一种资源类型，用于存储敏感信息), 二进制软件包，这些资源类型统统打到一个 ImageStream 里面，在“构建”这个动作的上下游还支持事件触发，比如定义“gitrepo的提交会触发一次构建”，以及“在构建完成后执行一次测试”。</li><li><strong>DeploymentConfig:</strong> 对 Replication Controller 的封装，定义了应用的运行时架构。</li><li><strong>Route:</strong> Kubernetes 定义了 Service 用于实现服务之间的隔离和调用，Openshift 在此之上增加了一层 Route，至此 Service 可以面向内网环境，而由 Route 来真正对外提供服务。</li></ul><p>将以上流程串起来，在 Openshift 上一个应用的诞生就应该是如下流程：</p><p><img src="/images/openshift_deploy_process.png" alt=""></p><p>熟悉了 Openshift 的基本概念，下面我们可以动手搭建一个 Openshift Origin 版，并在上面部署一个应用。</p><h1 id="Openshift-安装"><a href="#Openshift-安装" class="headerlink" title="Openshift 安装"></a>Openshift 安装</h1><p>这里安装的是 Openshift 社区版，官方也有提供 minishift（需要使用虚拟机）以及 Container 的方式安装，这里使用的方法是用 oc (openshift-cli)，是最简单，也是官方现在推荐的安装方式。<br>安装环境可以选择在 Mac 上或者是云虚拟机（Windows 不确定是否支持），我这里选择的是 AWS EC2，关于其他平台的安装，具体可参照<a href="https://github.com/openshift/origin/blob/master/docs/cluster_up_down.md" target="_blank" rel="noopener">https://github.com/openshift/origin/blob/master/docs/cluster_up_down.md</a></p><h2 id="第一步：在亚马逊上申请一个-Ubuntu-的机器"><a href="#第一步：在亚马逊上申请一个-Ubuntu-的机器" class="headerlink" title="第一步：在亚马逊上申请一个 Ubuntu 的机器"></a>第一步：在亚马逊上申请一个 Ubuntu 的机器</h2><p>有几个要注意的地方：</p><ul><li>CentOS 的 Dcoker 安装可能会遇到一些问题，是由于 Docker 社区版不支持，详见<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">这里</a>。</li><li>如果你想实现 hook 功能，即看到代码提交触发 Openshift 内构建的效果，你需要赋予 Instance 一个公网 IP。</li><li>安全组开启外部可访问 8443 端口。</li></ul><h2 id="第二步：安装-Docker"><a href="#第二步：安装-Docker" class="headerlink" title="第二步：安装 Docker"></a>第二步：安装 Docker</h2><p>这里要说明的是现有 Openshift 在 docker 的最高版本下支持有些问题，经测试 1.12.1版本是稳定的。<br>安装脚本：</p><pre><code># Install Docker on Xenial 16.04.1 x64# Ref https://docs.docker.com/engine/installation/linux/ubuntulinux/# No interactive for now.export DEBIAN_FRONTEND=noninteractive# Update your APT package index.sudo apt-get -y update# Update package information, ensure that APT works with the https method, and that CA certificates are installed.sudo apt-get -y install apt-transport-https ca-certificates# Add the new GPG key.sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D# Add docker.listsudo echo &quot;deb https://apt.dockerproject.org/repo ubuntu-xenial experimental&quot; &gt; /etc/apt/sources.list.d/docker.list# Update your APT package index.sudo apt-get -y update# Purge the old repo if it exists.sudo apt-get purge lxc-docker# Verify that APT is pulling from the right repository.sudo apt-cache policy docker-engine# Install the recommended package.sudo apt-get -y install linux-image-extra-$(uname -r)# Install Docker.sudo apt-get -y install docker-engine=1.12.1-0~xenial --allow-downgrades# Start the docker daemon.sudo service docker start# Validate docker versiondocker -v</code></pre><p>执行最后一条命令，出现 Dokcer 版本为 1.12.1 表示安装成功。</p><h2 id="第三步：配置-Dokcer-registry"><a href="#第三步：配置-Dokcer-registry" class="headerlink" title="第三步：配置 Dokcer registry"></a>第三步：配置 Dokcer registry</h2><p>编辑<code>/etc/systemd/system/multi-user.target.wants/docker.service</code> docker 的 service 文件，将<code>ExecStart=/usr/bin/dockerd -H fd://</code>这一行，替换为 <code>ExecStart=/usr/bin/dockerd --insecure-registry 172.30.0.0/16 -H fd://</code>，然后执行<code>systemctl reload-daemon docker</code>，<code>systemctl restart docker</code></p><h2 id="第四步：下载、启动-Openshift"><a href="#第四步：下载、启动-Openshift" class="headerlink" title="第四步：下载、启动 Openshift"></a>第四步：下载、启动 Openshift</h2><p>在服务器上下载<a href="https://github.com/openshift/origin/releases/download/v3.6.0-alpha.2/openshift-origin-client-tools-v3.6.0-alpha.2-3c221d5-linux-64bit.tar.gz" target="_blank" rel="noopener">openshift-origin-client-tools-v3.6.0-alpha.2-3c221d5-linux-64bit.tar.gz</a>oc 客户端，解压后把 oc 所在路径加入环境变量，执行：</p><pre><code>oc cluster up \--public-hostname=ec2-13-228-41-255.ap-southeast-1.compute.amazonaws.com \--routing-suffix=13.228.41.255.xip.io</code></pre><p>把以上命令中数字替换为你的 Instance 的公网 IP，即可启动一个外部可访问，应用也可以被外部访问的 Openshift 集群。</p><p><code>oc login system:admin</code>可以以管理员权限登录<br><code>oc login https://ec2-13-228-41-255.ap-southeast-1.compute.amazonaws.com:8443</code>可以以任意用户名密码登录<br>也可以直接访问 <a href="https://ec2-13-228-41-255.ap-southeast-1.compute.amazonaws.com:8443" target="_blank" rel="noopener">https://ec2-13-228-41-255.ap-southeast-1.compute.amazonaws.com:8443</a> 进行网页操作。</p><p>至此，Openshift 的安装全部完成。</p><h1 id="部署一个应用到-Openshift-上"><a href="#部署一个应用到-Openshift-上" class="headerlink" title="部署一个应用到 Openshift 上"></a>部署一个应用到 Openshift 上</h1><p>这一部分内容来自于 workshop，完整版可参照<a href="https://github.com/ADU-21/openshift-workshop" target="_blank" rel="noopener">https://github.com/ADU-21/openshift-workshop</a></p><h2 id="在本地安装-openshift-客户端"><a href="#在本地安装-openshift-客户端" class="headerlink" title="在本地安装 openshift 客户端"></a>在本地安装 openshift 客户端</h2><p>Mac 版：<a href="https://github.com/openshift/origin/releases/download/v3.6.0-alpha.2/openshift-origin-client-tools-v3.6.0-alpha.2-3c221d5-mac.zip" target="_blank" rel="noopener">openshift-origin-client-tools-v3.6.0-alpha.2-3c221d5-mac.zip</a><br>Windows 版： <a href="https://github.com/openshift/origin/releases/download/v3.6.0-alpha.2/openshift-origin-client-tools-v3.6.0-alpha.2-3c221d5-windows.zip" target="_blank" rel="noopener">openshift-origin-client-tools-v3.6.0-alpha.2-3c221d5-windows.zip</a><br>Linux 版：<a href="https://github.com/openshift/origin/releases/download/v3.6.0-alpha.2/openshift-origin-client-tools-v3.6.0-alpha.2-3c221d5-linux-64bit.tar.gz" target="_blank" rel="noopener">openshift-origin-client-tools-v3.6.0-alpha.2-3c221d5-linux-64bit.tar.gz</a></p><p>下载到本地之后解压，将一个名为 oc 的可执行文件路径放到 PATH 环境变量里，确保随处可执行。然后执行： <code>oc login https://ec2-13-228-41-255.ap-southeast-1.compute.amazonaws.com:8443</code>，输入任意用户名密码即可登录。</p><h2 id="部署一个应用"><a href="#部署一个应用" class="headerlink" title="部署一个应用"></a>部署一个应用</h2><p><strong>1</strong> 创建一个项目</p><pre><code>oc new-project [project name]</code></pre><p>Project 的作用是对 Openshift 的集群中的资源进行隔离。</p><p><strong>2</strong> 将一个<a href="https://github.com/openshift/nodejs-ex" target="_blank" rel="noopener">官方例子</a> fork 到自己的账户下，并克隆到本地：</p><pre><code>git clone https://github.com/&lt;your-github-name&gt;/nodejs-ex.git</code></pre><p>这里包含了项目所需代码，是一个 NodeJS 的应用，稍后我们将把这个应用部署到 Openshift 上。</p><p><strong>3</strong> 创建一个应用</p><pre><code>oc new-app https://github.com/&lt;your-github-name&gt;/nodejs-ex.git</code></pre><p>执行这一步命令，Openshift 会自动去查找 repo，根据代码的一些特征（比如<code>package.json</code>）识别这个项目类型，准备响应环境，可以通过<code>watch oc get all</code>的命令看到 openshift 实时创建了哪些资源，按逻辑顺序如下：</p><ul><li>bc: BuildConfig Openshift - 会先创建一个用于 Build image 的环境，然后创建一个叫做 Build 的对象，这个对象的实体是一个 Pod，在这个 Pod 中完成 Image 的构建</li><li>is: ImageStream - 用于管理 Image 的资源对象</li><li>bc: DeploymentConfig - 会创建一个 rc (Replication Controller)资源，又 rc 再去创建承载应用的 Pod</li><li>svc: Service - Pod 的负载均衡器，与 Kubernetes 中提到的 Service 相同</li><li>Pod: 除了提供运行环境的 Pod，这里还有 Build Pod(构建完成之后还会存在，可以用于查看 log)，Deploy Pod(部署完成后会被销毁)</li></ul><p>经历以上步骤，一个应用就已经在 Openshift 集群中被创建出来了。</p><p><strong>4</strong> 创建 route</p><pre><code>oc expose svc/nodejs-ex</code></pre><p>得到执行成功的提示后，执行<code>oc get route</code>，就可以用返回的地址访问你的应用了。<br>这个时候你会看到在<code>oc get all</code>命令中看到有叫做<code>route</code>的资源被创建了。</p><p><strong>5</strong> 清理资源</p><p>可以看到我们创建的资源都是被打上了 label 的，可以用<code>oc get all --show-labels=true</code>查看，删除资源也可以使用标签<code>oc delete all -l app=nodejs-example</code>，更粗暴的方式是直接删除整个 project，所有资源都会被清理掉：<code>oc delete project &lt;project name&gt;</code></p><blockquote><ul><li>Reference:</li><li><a href="https://github.com/openshift/origin/blob/master/docs/cluster_up_down.md" target="_blank" rel="noopener">https://github.com/openshift/origin/blob/master/docs/cluster_up_down.md</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Openshift 是一个基于 Kubernetes 和 Docker 的 PaaS 平台。&lt;/p&gt;
&lt;h1 id=&quot;Openshift-概念补充&quot;&gt;&lt;a href=&quot;#Openshift-概念补充&quot; class=&quot;headerlink&quot; title=&quot;Openshift 
      
    
    </summary>
    
      <category term="Cloud &amp; PaaS" scheme="https://www.duyidong.com/categories/Cloud-PaaS/"/>
    
    
      <category term="DevOps" scheme="https://www.duyidong.com/tags/DevOps/"/>
    
      <category term="PaaS" scheme="https://www.duyidong.com/tags/PaaS/"/>
    
      <category term="Openshift" scheme="https://www.duyidong.com/tags/Openshift/"/>
    
      <category term="Kubernetes" scheme="https://www.duyidong.com/tags/Kubernetes/"/>
    
      <category term="平台即服务" scheme="https://www.duyidong.com/tags/%E5%B9%B3%E5%8F%B0%E5%8D%B3%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
