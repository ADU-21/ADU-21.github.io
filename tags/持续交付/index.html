<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/styles.css"><title>标签：持续交付 | 杜屹东的博客</title></head><body><div class="container"><div class="columns page-header"><h1>杜屹东的博客</h1></div><div class="columns"><div class="navigation"><nav class="menus-main"><a href="/" class="favicon"><img alt="杜屹东的博客" src="/favicon.png"></a><a href="/about">关于我</a><a href="/list">日志列表</a><a href="/booklist">读书</a><a href="/links">链接</a><a href="/resume">简历</a></nav><nav class="right menus-right"><a target="_blank" href="https://github.com/ADU-21/blog">Fork on Github</a></nav></div></div><div class="columns"><div class="block-body column three-fourths"><div class="article-widget"><a href="https://www.duyidong.com/awsSolutionsArchitect_AE.pdf">AWS认证方案解决架构师证书</a></div><div class="article-widget"><strong>标签 #持续交付</strong></div><article><header><h2><a href="/2017/04/13/Infrastructure-as-Code-Testing/">基础设施代码测试</a></h2></header><div class="article-meta clearfix"><time class="left">2017 4 月 13 日</time><ul class="tags left"></ul><ul class="tags right"><li><a href="/tags/Infrastructure-as-Code/">Infrastructure as Code</a></li><li><a href="/tags/ThoughtWorks技术雷达/">ThoughtWorks技术雷达</a></li><li><a href="/tags/基础设施即代码/">基础设施即代码</a></li><li><a href="/tags/持续交付/">持续交付</a></li></ul></div><div class="markdown-body"><p>在DevOps的文化中有一个已经被广泛认可的概念叫做<a href="https://martinfowler.com/bliki/InfrastructureAsCode.html" target="_blank" rel="external">基础设施及代码</a>，意在将基础设施以配置文件的方式纳入版本管理以达到更灵活且便于管理的目的，从而更加适应基础设施频繁变更需求。</p>
<p>虽说此举俨然已将<a href="https://www.duyidong.com/2016/05/19/CI-CD/">CI/CD</a>（持续集成和持续交付）概念应用在了基础设施代码上，然而在应用产品的<a href="https://www.duyidong.com/tags/%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8F%91%E5%B8%83/">持续部署与发布</a>实施过程中，基础设施变更仍然是一件令人<em>胆战心惊</em>的事，原因很简单——没有<strong>反馈及时</strong>且<strong>覆盖充分</strong>的测试。</p>
<p>随着基础设施即代码的不断推广，这一痛点变得越来越明显，最近一期<a href="https://assets.thoughtworks.com/assets/technology-radar-vol-16-cn.pdf" target="_blank" rel="external">ThoughtWorks技术雷达</a>中列出了两个工具<strong>Molecule</strong>和<strong>Testinfra</strong>一个是用于测试Ansible Role(如果还不知道Ansible是什么请移步我的另一篇博客：<a href="https://www.duyidong.com/2016/06/15/Ansible%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/">Ansible学习小计</a>)，一个用于测试基础设施，下面我就来试用一下这两个工具。</p>
<h2 id="Testinfra介绍"><a href="#Testinfra介绍" class="headerlink" title="Testinfra介绍"></a>Testinfra介绍</h2><p><a href="https://github.com/philpep/testinfra" target="_blank" rel="external">Testinfra</a>是由Python社区贡献的基础设施实际状态自动化测试工具，其目标是成为<a href="http://serverspec.org/" target="_blank" rel="external">Serverspec</a>在Python中的等价物，并且作为<strong>Pytest</strong>测试引擎的插件来使用。</p>
<p>官方文档：<a href="http://testinfra.readthedocs.io/en/latest/index.html" target="_blank" rel="external">http://testinfra.readthedocs.io/en/latest/index.html</a></p>
<h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><p>环境准备：</p>
<pre><code>$ pip install testinfra      # 安装Testinfra
$ pip install paramiko       # Python的SSH支持以执行远程测试
$ pip install pytest-xdist   # 添加多线程支持
</code></pre><p>来感受下Testinfra的写法:</p>
<pre><code class="python">def test_passwd_file(File):         # 定义文件检查
    passwd = File(&quot;/etc/passwd&quot;)    # 定义文件
    assert passwd.contains(&quot;root&quot;)  # 文件是否包含关键字”root“
    assert passwd.user == &quot;root&quot;    # 文件owner是否为root
    assert passwd.group == &quot;root&quot;   # 文件所属组是否为root
    assert passwd.mode == 0644      # 检查文件权限


def test_nginx_is_installed(Package):
    nginx = Package(&quot;nginx&quot;)
    assert nginx.is_installed       # nginx是否安装
    assert nginx.version.startswith(&quot;1.10&quot;) # 检查nginx版本


def test_nginx_running_and_enabled(Service):
    nginx = Service(&quot;nginx&quot;)
    assert nginx.is_running         # 检查nginx是否已启动
    assert nginx.is_enabled         # nginx是否配置开机自启
</code></pre>
<p>基本和Python的单元测试一模一样，下面来看运行结果：</p>
<pre><code>$ testinfra -v test_myinfra.py
</code></pre><p><img src="/images/Testinfra_local_success.png" alt=""></p>
<p>报错也是PyTest的尿性：</p>
<p><img src="/images/Testinfra_local_fail.png" alt=""></p>
<h3 id="远程测试虚拟机"><a href="#远程测试虚拟机" class="headerlink" title="远程测试虚拟机"></a>远程测试虚拟机</h3><p>通过配置ssh并在启动时加入如下参数：</p>
<pre><code># -n 为指定并发数 --connection为指定链接方式
$ testinfra -n 1 -v --host=&quot;hostname&quot; --connection=ssh test_myinfra.py
</code></pre><p>感觉执行方式和Ansible有些相似，以下为执行结果：</p>
<p><img src="/images/Testinfra_remote_success.png" alt=""></p>
<p>耗时6s，中规中矩吧。</p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>除了SSH协议链接Testinfra还支持paramiko，docker，salt，kubectl等连接方式，对于Docker的测试，无外乎也是在起起来的容器上使用<code>docker exec</code>的方法对基础设施即环境配置进行验证。</p>
<p>另外Testinfra支持自定义module的形式保证测试方法的灵活性，同时Testinfra可以再PyTest之外用于调用SSH连接从而进行测试，形如：</p>
<pre><code>&gt;&gt;&gt; import testinfra
&gt;&gt;&gt; conn = testinfra.get_backend(&quot;paramiko://root@server:2222&quot;, sudo=True)
&gt;&gt;&gt; conn.File(&quot;/etc/shadow&quot;).mode == 0640
True
</code></pre><h3 id="Testinfra评价"><a href="#Testinfra评价" class="headerlink" title="Testinfra评价"></a>Testinfra评价</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>基本涵盖了应用所需环境测试的内容，且可灵活扩展。</li>
<li>可读性好，学习成本低.</li>
<li>环境依赖简单，能够与项目完美结合。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>测试未能覆盖到IaaS层的测试，仅能够在操作系统之上进行测试。对于云环境的基础设施还包括网络，负载均衡，数据库等等资源，这些都不能照顾到。</li>
<li>测试覆盖率虽然有所提升，但反馈不够及时。在开发和Debug过程中最痛苦的应该是每次使用新代码创建基础设施都要等很久才能得到反馈，这个问题并没有得到解决。</li>
<li>报错信息不够友好，个人认为基础设施的测试应该不能等同于代码层面的测试，所以PyTest的报错方式并不能让用户一眼就看到是哪方面出了错误；往远了说，要根据这个报错信息Trigger一个行为也很难做到。</li>
</ul>
<h2 id="Molecule介绍"><a href="#Molecule介绍" class="headerlink" title="Molecule介绍"></a>Molecule介绍</h2><p><a href="https://github.com/metacloud/molecule" target="_blank" rel="external">MOLECULE</a>旨在帮助开发和测试Ansible的Role。通过在虚拟机或容器上为正在运行的Ansible Role的测试构<br>建脚手架，我们无需再手工创建这些测试环境。Molecule利用Vagrant，Docker和OpenStack来管理虚拟机或容器，并支持Serverspec、Testinfra或Goss来运行测试。在sequence facility model中的默认步骤包括：虚拟机管理，Ansible语法静态检查，幂等性测试和收敛性测试。</p>
<p>话不多说，我们来看看这个工具究竟能解决什么样的问题吧。</p>
<h3 id="版本支持"><a href="#版本支持" class="headerlink" title="版本支持"></a>版本支持</h3><p>目前Molecule支持的Ansible版本为<code>2.1.4.0</code>和<code>2.2.1.0</code>，好吧，这一点，虽然项目上还在用<code>1.7.2</code>（一直担心<em>Breake change</em>所以没有升上去），但我觉得大部分公司应该使用的是<code>2.2</code>以上的版本，这一点我没有异议。</p>
<h3 id="Quick-Start-1"><a href="#Quick-Start-1" class="headerlink" title="Quick Start"></a>Quick Start</h3><p>环境准备</p>
<pre><code>$ yum install ansible -y      # 为了避免踩坑不使用pip的ansible
$ pip install docker          # 安装python的docker支持
$ pip install molecule        # 主角登场
</code></pre><p>运行</p>
<pre><code>$ molecule init --role foo --driver docker
$ cd foo
$ molecule test
</code></pre><p>运行结果：</p>
<p><img src="/images/Molecule_Test_Success.png" alt=""></p>
<p>第一次运行速度比较慢，因为运行Ansible需要到Docker镜像仓库拉取一个Ubuntu的镜像，可以从Log里看出，整个测试过程包含如下步骤：</p>
<ul>
<li>从基础镜像（Ubuntu）创建一个测试需要的镜像（docker image）</li>
<li>从镜像启动一个测试运行需要的容器（docker container）</li>
<li>开始测试，运行playbook</li>
<li>使用Testinfra判断准备环境是否正确</li>
<li>测试完毕，停止并删除容器</li>
</ul>
<p>整个过程容器的创建和销毁并没有占用很多时间，和跑一个Ansible时间相差不多。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Molecule的配置文件采用的yml，可以在项目下也可以放到<code>~/.config/molecule/config.yml</code>作为默认配置，示例如下：</p>
<pre><code>---
dependency:
  name: galaxy         # Molecule使用Ansible Galaxy拉取Role
driver:
  name: docker         # 使用Docker引擎跑测试
docker:
  containers:          # 容器配置
    - name: foo
      image: ubuntu
      image_version: latest
      ansible_groups:  # 目标机器组
        - group1
verifier:
  name: testinfra      # 验证最终执行结果
</code></pre><p>其中Driver除了Docker还支持OpenStack及Vagrant，Verifier除了Testinfra还可选Serverspec及Goss。</p>
<h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p>关于测试内容的定义，看一下<code>test/test_default.py</code>文件：</p>
<pre><code>import testinfra.utils.ansible_runner

testinfra_hosts = testinfra.utils.ansible_runner.AnsibleRunner(
    &#39;.molecule/ansible_inventory&#39;).get_hosts(&#39;all&#39;)


def test_hosts_file(File):
    f = File(&#39;/etc/hosts&#39;)

    assert f.exists
    assert f.user == &#39;root&#39;
    assert f.group == &#39;root&#39;
</code></pre><p>简单看来就是利用Testinfra看了下/etc/hosts是否存在，所属用户和所属组是否为root</p>
<h3 id="Molecule评价"><a href="#Molecule评价" class="headerlink" title="Molecule评价"></a>Molecule评价</h3><p>与其说Molecule是一个新的Ansible测试工具不如说是一种组合docker，Testinfra和Ansible的测试方法，换总说法它并不是一个集成在Ansible之中的更细粒度的测试方法，而是高于Ansible的更适合于放在Pipeline中作为测试Ansible运行最终结果的一个工具集，其效果大致和运行<code>docker run XXX ansible</code>之后再运行<code>Testinfra -v</code>两行shell命令是一样的</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>开始关注自动化配置脚本的测试，不失为一种尝试</li>
<li>使用Docker作为引擎，速度还可以</li>
<li>能够提升更改Ansible脚本后的构建信心</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>仍然要运行完Playbook才能看到结果，并没有解决<strong>反馈不及时</strong>的痛点</li>
<li>不支持细粒度的测试，且对一个playbook使用不同参数构建不同环境的应用场景也没有很好的支持</li>
<li>不管是使用Docker还是Vagrant，都增加了<em>空间</em>的消耗，且增加了<em>知识成本</em></li>
</ul>
<h2 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h2><p>随着DevOps的普及，已经有人开始关注基础设施代码测试这一块的工作，但这些测试工具还在初级阶段，反馈不能及时，增加覆盖面的成本也还较高，且不能很好地与云环境结合。<br>由于在软件开发中基础设施对业务价值的贡献并不明显，提升Ops技能与其说能过帮助公司挣钱不如说是帮公司省钱；而且在大部分项目中基础设施变更并没有那么频繁，紧急的问题通常还是由Ops（或者是被称为DevOps的一个角色）手动来解决，这种现象在国内公司尤其明显。大家对DevOps的认识还没有达到不一致，DevOps中的测试也还没有被定义清楚，基础设施代码的测试，还有很长的路要走。</p>
</div></article><article><header><h2><a href="/2016/10/24/部署和发布策略的演进/">部署和发布策略的演进</a></h2></header><div class="article-meta clearfix"><time class="left">2016 10 月 24 日</time><ul class="tags left"></ul><ul class="tags right"><li><a href="/tags/持续交付/">持续交付</a></li><li><a href="/tags/DevOps/">DevOps</a></li><li><a href="/tags/部署与发布/">部署与发布</a></li><li><a href="/tags/持续部署/">持续部署</a></li></ul></div><div class="markdown-body"><h1 id="持续交付的目的"><a href="#持续交付的目的" class="headerlink" title="持续交付的目的"></a>持续交付的目的</h1><h2 id="以下问题有没有解决？"><a href="#以下问题有没有解决？" class="headerlink" title="以下问题有没有解决？"></a>以下问题有没有解决？</h2><p>“快速将产品推向市场” 与 “提供稳定、安全并可靠的IT服务” 是否可以兼得？<br>用更少的资源完成更多的业绩，既要保持竞争力，又要削减成本；<br>如何解决任务交接出现的问题，例如业务与开发，开发与运维之间；<br>运维人员能否和其他人一样，正常上下班，而不用在夜里或者周末加班？</p>
<a id="more"></a>
<h1 id="部署和发布的区别"><a href="#部署和发布的区别" class="headerlink" title="部署和发布的区别"></a>部署和发布的区别</h1><p>要弄清楚部署和发布的区别，首先要弄清楚几个名词之间的关系CI(Continues Intergation)持续集成，CD(Continues Delivery)持续交付，持续集成的目的是对代码的快速反馈，在分布式开发的团队中你的更改不会破坏已有代码功能，持续交付的scope要大一些，指的是对用户交付最终价值，传统的交付最终价值即为产生可发布的版本，有的公司在持续交付的基础之上甚至提出了持续部署（Continous Deployment），即自动化讲可发布版本放入到产品环境，其中就涉及到蓝绿部署，滚动部署等部署方式。在部署和发布解耦之后，在将产品部署到产品环境之后我们可能还有些功能是不想对用户可见的，在对用户可见的的这个过程我们称之为发布（Release）（如图）。DevOps运动则是在发布之后有引入运维和运营的角色，和用户反馈一起形成一个闭环。恩，差不多是这个样子的。</p>
<p><img src="https://puppet.com/sites/default/files/2016-09/puppet_continuous_diagram.gif" alt=""></p>
<p>ThoughtWorks在15年的技术雷达上已经建议解耦部署和发布:</p>
<pre><code class="我们推荐严格区分术语“部署（Deployment）”和“发布（Release）”的使用。应用组件或基本设施的代码或配置变更在产品环境生效称为“部署”，而具有业务影响的功能变化对最终用户可见称为“发布”。使用特性开关或灰度发布等技巧可以使我们更加频繁地部署变更到产品环境但并不发布功能。频繁部署可以有效降低变更带来的风险，同时业务负责人仍然能保持何时向最终用户发布功能的控制。```">
# 零宕机发布（目标）
```零宕机发布指的一种将用户从一个版本几乎瞬间转移到另一个版本上的方法，更重要的是，如果出了什么问题，他还要能在瞬间把用户从这个版本转回到原先的版本上。
</code></pre>
<p>零宕机发布的关键在于将发布流程中不同的部分解耦，尽量使他们能独立发生。</p>
<h1 id="凤凰式部署"><a href="#凤凰式部署" class="headerlink" title="凤凰式部署"></a>凤凰式部署</h1><p>将产品环境和应用打包发布，在容器产生之前是将系统和应用制作镜像的方式进行发布，避免产品环境和非生产环境不一致导致发布失败，但是这种发布方式因为笨重而被容器取代。</p>
<ul>
<li>便于回滚</li>
<li>提高计算资源的利用率：相对以操作系统为计算单元的管理方式，容器不仅更轻量而且极大提高了计算资源的利用率，且容器本身不占用计算资源。而且相对image的方式，管理成本，备份的cost也极大降低</li>
<li>更快的部署时间：image的方式需要一天，snapshot需要十分钟，Container则可以把这个时间缩短到秒级</li>
<li>解决了环境不一致的问题</li>
<li>跨平台</li>
<li>prodocut team over project team:每个team可以更方便的管理自己的platform资源，极大地降低了team之间的沟通成本。（相对application team和platfor team分离的情况）</li>
</ul>
<p>风险：安全，容器必须是以root权限泡在宿主机上，不同容器共享一个宿主机，如果一个容器被贡献则会威胁到所有在改宿主机上的服务。<br>解决方案：</p>
<ul>
<li>及时更新宿主机系统版本，避免内核漏洞</li>
<li>扫描bese image, 避免Container本身系统漏洞</li>
<li>base image可以加入主动防御（e.g.ossec）</li>
<li>控制好容器操作权限</li>
</ul>
<h1 id="滚动发布-Rolling-Release"><a href="#滚动发布-Rolling-Release" class="headerlink" title="滚动发布(Rolling Release)"></a>滚动发布(Rolling Release)</h1><p>又称滚动更新(rolling update)<br>指的是在不切换负载均衡器或者DNS的前提下把负载均衡器下的机器一台台关掉，部署好之后再挂到负载均衡器下面，与蓝绿部署直观的差别是不需要切换负载均衡器或DNS，同时做到零宕机部署。（还要完善）</p>
<h1 id="蓝绿部署（BuleGreen-Deployment）"><a href="#蓝绿部署（BuleGreen-Deployment）" class="headerlink" title="蓝绿部署（BuleGreen Deployment）"></a>蓝绿部署（BuleGreen Deployment）</h1><p>在发布之前就把应用程序放在产品环境上部署好，如果“发布”能像重新配置一下路由器那样简单，让他直接指向生产环境，那就更好了 ————《持续交付》<br>蓝绿部署主要解决的是宕机发布的问题<br>它的主要原理是在保持旧版本环境（绿环境）正常运行的情况下，准备一套蓝环境，在产品环境里蓝环境通过充分冒烟测试后再将用户访问从绿环境切换到蓝环境，如果蓝环境在这个切换之后出现问题则立即切换回绿环境，如果没有问题则最后destroy掉绿环境，具体做法可以通过DNS或者ELB配合AutoScaling Group进行Infrastructure的切换，这种切换通常在一秒之内就可以搞定。application层的回话切换以及数据库链接切换的问题，可以使用中间件解决。</p>
<p><img src="http://martinfowler.com/bliki/images/blueGreenDeployment/blue_green_deployments.png" alt=""></p>
<p>对于数据库，直接从绿环境切换到蓝环境是不可能的，因为如果数据库结构发生改变的话，数据迁移需要时间。解决这种情况最理想的方法是在一小段时间把数据库变成只读状态，完成迁移后再将用户切换到蓝环境，恢复读写。如果在切换过程中仍然有数据的写入，你可以采用添加中间件的方式保存读写数据，或者在在读写过程中持续将事物发向新旧两个数据库。<br></p>
<h1 id="灰度发布（金丝雀发布）"><a href="#灰度发布（金丝雀发布）" class="headerlink" title="灰度发布（金丝雀发布）"></a>灰度发布（金丝雀发布）</h1><p>在把应用程序发布给所有人之前，先试着把它发布给一小撮用户群，这种技术叫做金丝雀发布。<br>金丝雀发布要解决的问题主要是缩短反馈周期，以及弥补巨大产品环境下无法进行有效容量测试所可能导致的问题的一种手段。是一个能大大降低新版本发布风险的方法。<br>灰度发布是蓝绿部署的一个延伸，采用逐步切换的方式使新版本发布只影响到尽可能少的用户，从而为AB测试提供条件。灰度发布<br>灰度发布与金丝雀部署在操作上是等价的<br>金丝雀发有以下几个好处：</p>
<ul>
<li>非常容易回滚，这个其实是蓝绿部署就已经带来的好处，只要不把用户引向有问题的新版本，就可以有足够的时间用来分析错误日志，排查问题。</li>
<li>可以将同一批用户引至不新旧版本以进行A/B测试，某些公司可以度量新特性的使用率，某些公司可以度量该版本带来的收益，你不必将大量用户引入A/B测试，只需要有代表性的样本就足够了。</li>
<li>可以通过逐渐增加负载，记录并衡量应用程序响应时间，CPU使用率，I/O，内存使用率以及日志中是否有异常报告这种方式来检查应用程序是否满足容量需求，降低容量测试不理想带来的风险。</li>
</ul>
<p>另外，需要注意的是，在生产环境中保留尽可能少的版本也是非常重要的，最好限制在两个版本之内。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>紧急修复：一定不要破坏流程，不要直接对生产环境进行修改。</li>
<li>持续部署：If it hurts, do it more often</li>
<li>持续发布用户自行安装的软件？发布方式？</li>
<li>执行部署的人应该参与部署过程的创建（Dev和Ops的紧密合作）</li>
<li>记录部署活动（自动化更佳）</li>
<li>不要删除旧文件，而是移动到别的位置。在Unix环境中，一个最佳实践是把每个版本部署到不同的文件夹中，创建一个符号链接文件指向最新版本，版本的部署和回滚就只是改一下符号链接这么简单。</li>
<li>部署是整个团队的责任（DevOps）</li>
<li>快速失败，部署脚本也应该纳入测试中，这些测试应该被作为部署的一部分来工作。</li>
<li>数据库最好向前兼容</li>
</ul>
</div></article><div class="archive-pagination"><div class="paginator"><span class="page-number current">1</span></div></div></div><div class="block-sidebar column one-fourth"><div class="widget text-content"><p>杜屹东 生于 1993.12.16, 英文 ID Luke Du</p>
<ul>
<li>现就职于<a href="https://www.thoughtworks.com/">ThoughtWorks</a></li>
<li>毕业于 <a href="http://www.xhu.edu.cn/">西华大学</a> 计算机科学与技术</li>
<li>AWS认证方案解决架构师</li>
<li>喜欢<a href="http://baike.baidu.com/view/39292.htm">史铁生</a>, <a href="https://movie.douban.com/celebrity/1012521/">David Fincher</a> 和 <a href="http://baike.baidu.com/view/2556.htm">陈奕迅</a></li>
<li>在剧组和影视公司工作过，曾参与成龙大哥电影<a href="https://movie.douban.com/subject/24529353/">《绝地逃亡》</a>制作</li>
<li>曾骑行成都-拉萨，成都-北京，海南环岛</li>
</ul>
<p>目前专注于：</p>
<ul>
<li>Cloud Native - 云解决方案</li>
<li>Serverless - 无服务器架构</li>
<li>Fintech - 金融科技</li>
<li>DevOps - 文化组织变革</li>
<li>CI/CD - 持续集成与持续交付</li>
</ul>
</div><div class="widget tags"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWS/">AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWS认证考试/">AWS认证考试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Agile/">Agile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ansible/">Ansible</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blog/">Blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CDN/">CDN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Certification/">Certification</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cloud-Native/">Cloud Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cloudfront/">Cloudfront</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataBase/">DataBase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DevOps/">DevOps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EC2/">EC2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/">HTTPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IAM/">IAM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Infrastructure-as-Code/">Infrastructure as Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Route53/">Route53</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/S3/">S3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Serverless/">Serverless</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Study/">Study</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDD/">TDD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThoughtWorks/">ThoughtWorks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThoughtWorks技术雷达/">ThoughtWorks技术雷达</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/上云/">上云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云计算/">云计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云计算认证/">云计算认证</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云计算资源/">云计算资源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/亚马逊认证与权限/">亚马逊认证与权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码/">代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/凤凰式服务/">凤凰式服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客上云/">博客上云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础设施即代码/">基础设施即代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大事记/">大事记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象存储服务/">对象存储服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小结/">小结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小计/">小计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/持续交付/">持续交付</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/持续部署/">持续部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/无服务器架构/">无服务器架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本管理/">版本管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻译/">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/职场/">职场</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化运维/">自动化运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/部署与发布/">部署与发布</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/雪花服务器/">雪花服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul></div><div class="widget archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">5</span></li></ul></div><div class="widget text-content"><p>该博客使用基于 &nbsp;<a href="http://hexo.io">Hexo</a>&nbsp; 的 &nbsp;<a href="https://github.com/jysperm/hexo-theme-simpleblock">simpleblock</a>&nbsp; 主题。博客内容使用 &nbsp;<a href="https://aws.amazon.com/s3/">Amazon S3</a>&nbsp; 发布。最后生成于 2017-04-15.</p></div></div></div></div><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-80279850-1', 'auto');
ga('send', 'pageview');
</script><script>window.duoshuoQuery = {short_name: 'duuyidong'}</script><script src="https://static.duoshuo.com/embed.js"></script></body></html>